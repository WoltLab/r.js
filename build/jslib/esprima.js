/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
if(typeof define === 'function' && define.amd)
define([], factory);
	else if(typeof exports === 'object' && typeof module === 'object')
	module.exports = factory();
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/tsc/cjs/assert.js":
/*!********************************!*\
  !*** ./dist/tsc/cjs/assert.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Ensure the condition is true, otherwise throw an error.\n// This is only to have a better contract semantic, i.e. another safety net\n// to catch a logic error. The condition shall be fulfilled in normal case.\n// Do NOT use this to enforce a certain condition on any user input.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assert = void 0;\nfunction assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n        throw new Error('ASSERT: ' + message);\n    }\n}\nexports.assert = assert;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/assert.js?");

/***/ }),

/***/ "./dist/tsc/cjs/character.js":
/*!***********************************!*\
  !*** ./dist/tsc/cjs/character.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Character = void 0;\n// See also tools/generate-unicode-regex.js.\nvar Regex = {\n    // Unicode v12.1.0 NonAsciiIdentifierStart:\n    NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDEC0-\\uDEEB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/,\n    // Unicode v12.1.0 NonAsciiIdentifierPart:\n    // eslint-disable-next-line no-misleading-character-class\n    NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD46\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E\\uDC5F\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n};\nexports.Character = {\n    fromCodePoint: function (cp) {\n        return (cp < 0x10000) ? String.fromCharCode(cp) :\n            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +\n                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));\n    },\n    isStringWellFormedUnicode: function (text) {\n        for (var i = 0; i < text.length; i++) {\n            var c = text.charCodeAt(i);\n            if (c >= 0xD800 && c <= 0xDBFF) {\n                if (i === text.length - 1) {\n                    return false;\n                }\n                i++;\n                c = text.charCodeAt(i);\n                if (c < 0xDC00 && c > 0xDFFF) {\n                    return false;\n                }\n            }\n            else if (c >= 0xDC00 && c <= 0xDFFF) {\n                return false;\n            }\n        }\n        return true;\n    },\n    // https://tc39.github.io/ecma262/#sec-white-space\n    isWhiteSpace: function (cp) {\n        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||\n            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);\n    },\n    // https://tc39.github.io/ecma262/#sec-line-terminators\n    isLineTerminator: function (cp) {\n        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);\n    },\n    // https://tc39.github.io/ecma262/#sec-names-and-keywords\n    isIdentifierStart: function (cp) {\n        return (cp === 0x24) || (cp === 0x5F) || // $ (dollar) and _ (underscore)\n            (cp >= 0x41 && cp <= 0x5A) || // A..Z\n            (cp >= 0x61 && cp <= 0x7A) || // a..z\n            (cp === 0x5C) || // \\ (backslash)\n            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));\n    },\n    isIdentifierPart: function (cp) {\n        return (cp === 0x24) || (cp === 0x5F) || // $ (dollar) and _ (underscore)\n            (cp >= 0x41 && cp <= 0x5A) || // A..Z\n            (cp >= 0x61 && cp <= 0x7A) || // a..z\n            (cp >= 0x30 && cp <= 0x39) || // 0..9\n            (cp === 0x5C) || // \\ (backslash)\n            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));\n    },\n    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\n    isDecimalDigit: function (cp) {\n        return (cp >= 0x30 && cp <= 0x39); // 0..9\n    },\n    isDecimalDigitChar: function (ch) {\n        return ch.length === 1 && exports.Character.isDecimalDigit(ch.charCodeAt(0));\n    },\n    isHexDigit: function (cp) {\n        return (cp >= 0x30 && cp <= 0x39) || // 0..9\n            (cp >= 0x41 && cp <= 0x46) || // A..F\n            (cp >= 0x61 && cp <= 0x66); // a..f\n    },\n    isHexDigitChar: function (ch) {\n        return ch.length === 1 && exports.Character.isHexDigit(ch.charCodeAt(0));\n    },\n    isOctalDigit: function (cp) {\n        return (cp >= 0x30 && cp <= 0x37); // 0..7\n    },\n    isOctalDigitChar: function (ch) {\n        return ch.length === 1 && exports.Character.isOctalDigit(ch.charCodeAt(0));\n    }\n};\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/character.js?");

/***/ }),

/***/ "./dist/tsc/cjs/comment-handler.js":
/*!*****************************************!*\
  !*** ./dist/tsc/cjs/comment-handler.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CommentHandler = void 0;\nvar syntax_1 = __webpack_require__(/*! ./syntax */ \"./dist/tsc/cjs/syntax.js\");\nvar CommentHandler = /** @class */ (function () {\n    function CommentHandler() {\n        this.attach = false;\n        this.comments = [];\n        this.stack = [];\n        this.leading = [];\n        this.trailing = [];\n    }\n    CommentHandler.prototype.insertInnerComments = function (node, metadata) {\n        //  innnerComments for properties empty block\n        //  `function a() {/** comments **\\/}`\n        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {\n            var innerComments = [];\n            for (var i = this.leading.length - 1; i >= 0; --i) {\n                var entry = this.leading[i];\n                if (metadata.end.offset >= entry.start) {\n                    innerComments.unshift(entry.comment);\n                    this.leading.splice(i, 1);\n                    this.trailing.splice(i, 1);\n                }\n            }\n            if (innerComments.length) {\n                node.innerComments = innerComments;\n            }\n        }\n    };\n    CommentHandler.prototype.findTrailingComments = function (metadata) {\n        var trailingComments = [];\n        if (this.trailing.length > 0) {\n            for (var i = this.trailing.length - 1; i >= 0; --i) {\n                var entry = this.trailing[i];\n                if (entry.start >= metadata.end.offset) {\n                    trailingComments.unshift(entry.comment);\n                }\n            }\n            this.trailing.length = 0;\n            return trailingComments;\n        }\n        var last = this.stack[this.stack.length - 1];\n        if (last && last.node.trailingComments) {\n            var firstComment = last.node.trailingComments[0];\n            if (firstComment && firstComment.range[0] >= metadata.end.offset) {\n                trailingComments = last.node.trailingComments;\n                delete last.node.trailingComments;\n            }\n        }\n        return trailingComments;\n    };\n    CommentHandler.prototype.findLeadingComments = function (metadata) {\n        var leadingComments = [];\n        var target;\n        while (this.stack.length > 0) {\n            var entry = this.stack[this.stack.length - 1];\n            if (entry && entry.start >= metadata.start.offset) {\n                target = entry.node;\n                this.stack.pop();\n            }\n            else {\n                break;\n            }\n        }\n        if (target) {\n            var count = target.leadingComments ? target.leadingComments.length : 0;\n            for (var i = count - 1; i >= 0; --i) {\n                var comment = target.leadingComments[i];\n                if (comment.range[1] <= metadata.start.offset) {\n                    leadingComments.unshift(comment);\n                    target.leadingComments.splice(i, 1);\n                }\n            }\n            if (target.leadingComments && target.leadingComments.length === 0) {\n                delete target.leadingComments;\n            }\n            return leadingComments;\n        }\n        for (var i = this.leading.length - 1; i >= 0; --i) {\n            var entry = this.leading[i];\n            if (entry.start <= metadata.start.offset) {\n                leadingComments.unshift(entry.comment);\n                this.leading.splice(i, 1);\n            }\n        }\n        return leadingComments;\n    };\n    CommentHandler.prototype.visitNode = function (node, metadata) {\n        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {\n            return;\n        }\n        this.insertInnerComments(node, metadata);\n        var trailingComments = this.findTrailingComments(metadata);\n        var leadingComments = this.findLeadingComments(metadata);\n        if (leadingComments.length > 0) {\n            node.leadingComments = leadingComments;\n        }\n        if (trailingComments.length > 0) {\n            node.trailingComments = trailingComments;\n        }\n        this.stack.push({\n            node: node,\n            start: metadata.start.offset\n        });\n    };\n    CommentHandler.prototype.visitComment = function (node, metadata) {\n        var type = (node.type[0] === 'L') ? 'Line' : 'Block';\n        var comment = {\n            type: type,\n            value: node.value\n        };\n        if (node.range) {\n            comment.range = node.range;\n        }\n        if (node.loc) {\n            comment.loc = node.loc;\n        }\n        this.comments.push(comment);\n        if (this.attach) {\n            var entry = {\n                comment: {\n                    type: type,\n                    value: node.value,\n                    range: [metadata.start.offset, metadata.end.offset]\n                },\n                start: metadata.start.offset\n            };\n            if (node.loc) {\n                entry.comment.loc = node.loc;\n            }\n            node.type = type;\n            this.leading.push(entry);\n            this.trailing.push(entry);\n        }\n    };\n    CommentHandler.prototype.visit = function (node, metadata) {\n        if (node.type === 'LineComment') {\n            this.visitComment(node, metadata);\n        }\n        else if (node.type === 'BlockComment') {\n            this.visitComment(node, metadata);\n        }\n        else if (this.attach) {\n            this.visitNode(node, metadata);\n        }\n    };\n    return CommentHandler;\n}());\nexports.CommentHandler = CommentHandler;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/comment-handler.js?");

/***/ }),

/***/ "./dist/tsc/cjs/error-handler.js":
/*!***************************************!*\
  !*** ./dist/tsc/cjs/error-handler.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ErrorHandler = void 0;\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n        this.errors = [];\n        this.tolerant = false;\n    }\n    ErrorHandler.prototype.recordError = function (error) {\n        this.errors.push(error);\n    };\n    ErrorHandler.prototype.tolerate = function (error) {\n        if (this.tolerant) {\n            this.recordError(error);\n        }\n        else {\n            throw error;\n        }\n    };\n    ErrorHandler.prototype.constructError = function (msg, column) {\n        var error = new Error(msg);\n        try {\n            throw error;\n        }\n        catch (base) {\n            /* istanbul ignore else */\n            if (Object.create && Object.defineProperty) {\n                error = Object.create(base);\n                Object.defineProperty(error, 'column', { value: column });\n            }\n        }\n        /* istanbul ignore next */\n        return error;\n    };\n    ErrorHandler.prototype.createError = function (index, line, col, description) {\n        var msg = 'Line ' + line + ': ' + description;\n        var _error = this.constructError(msg, col);\n        _error.index = index;\n        _error.lineNumber = line;\n        _error.description = description;\n        var error = _error;\n        return error;\n    };\n    ErrorHandler.prototype.throwError = function (index, line, col, description) {\n        throw this.createError(index, line, col, description);\n    };\n    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {\n        var error = this.createError(index, line, col, description);\n        if (this.tolerant) {\n            this.recordError(error);\n        }\n        else {\n            throw error;\n        }\n    };\n    return ErrorHandler;\n}());\nexports.ErrorHandler = ErrorHandler;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/error-handler.js?");

/***/ }),

/***/ "./dist/tsc/cjs/esprima.js":
/*!*********************************!*\
  !*** ./dist/tsc/cjs/esprima.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n  Copyright JS Foundation and other contributors, https://js.foundation/\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = exports.Syntax = exports.Nodes = exports.tokenize = exports.parseScript = exports.parseModule = exports.parse = void 0;\nvar comment_handler_1 = __webpack_require__(/*! ./comment-handler */ \"./dist/tsc/cjs/comment-handler.js\");\nvar jsx_parser_1 = __webpack_require__(/*! ./jsx-parser */ \"./dist/tsc/cjs/jsx-parser.js\");\nvar parser_1 = __webpack_require__(/*! ./parser */ \"./dist/tsc/cjs/parser.js\");\nvar tokenizer_1 = __webpack_require__(/*! ./tokenizer */ \"./dist/tsc/cjs/tokenizer.js\");\nvar syntax_1 = __webpack_require__(/*! ./syntax */ \"./dist/tsc/cjs/syntax.js\");\n__exportStar(__webpack_require__(/*! ./nodes */ \"./dist/tsc/cjs/nodes.js\"), exports);\nvar Nodes = __webpack_require__(/*! ./nodes */ \"./dist/tsc/cjs/nodes.js\");\nexports.Nodes = Nodes;\nfunction parse(code, options, delegate) {\n    var commentHandler = null;\n    var proxyDelegate = function (node, metadata) {\n        if (delegate) {\n            delegate(node, metadata);\n        }\n        if (commentHandler) {\n            commentHandler.visit(node, metadata);\n        }\n    };\n    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;\n    var collectComment = false;\n    if (options) {\n        collectComment = (typeof options.comment === 'boolean' && options.comment);\n        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);\n        if (collectComment || attachComment) {\n            commentHandler = new comment_handler_1.CommentHandler();\n            commentHandler.attach = attachComment;\n            options.comment = true;\n            parserDelegate = proxyDelegate;\n        }\n    }\n    var isModule = false;\n    if (options && typeof options.sourceType === 'string') {\n        isModule = (options.sourceType === 'module');\n    }\n    var parser;\n    if (options && typeof options.jsx === 'boolean' && options.jsx) {\n        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);\n    }\n    else {\n        parser = new parser_1.Parser(code, options, parserDelegate);\n    }\n    var program = isModule ? parser.parseModule() : parser.parseScript();\n    var ast = program;\n    if (collectComment && commentHandler) {\n        ast.comments = commentHandler.comments;\n    }\n    if (parser.config.tokens) {\n        ast.tokens = parser.tokens;\n    }\n    if (parser.config.tolerant) {\n        ast.errors = parser.errorHandler.errors;\n    }\n    return ast;\n}\nexports.parse = parse;\nfunction parseModule(code, options, delegate) {\n    var parsingOptions = options || {};\n    parsingOptions.sourceType = 'module';\n    return parse(code, parsingOptions, delegate);\n}\nexports.parseModule = parseModule;\nfunction parseScript(code, options, delegate) {\n    var parsingOptions = options || {};\n    parsingOptions.sourceType = 'script';\n    return parse(code, parsingOptions, delegate);\n}\nexports.parseScript = parseScript;\nfunction tokenize(code, options, delegate) {\n    var tokenizer = new tokenizer_1.Tokenizer(code, options);\n    var tokens = [];\n    try {\n        while (true) {\n            var token = tokenizer.getNextToken();\n            if (!token) {\n                break;\n            }\n            if (delegate) {\n                token = delegate(token);\n            }\n            tokens.push(token);\n        }\n    }\n    catch (e) {\n        tokenizer.errorHandler.tolerate(e);\n    }\n    if (tokenizer.errorHandler.tolerant) {\n        tokens.errors = tokenizer.errors();\n    }\n    return tokens;\n}\nexports.tokenize = tokenize;\nvar syntax_2 = __webpack_require__(/*! ./syntax */ \"./dist/tsc/cjs/syntax.js\");\nObject.defineProperty(exports, \"Syntax\", ({ enumerable: true, get: function () { return syntax_2.Syntax; } }));\n// Sync with *.json manifests.\nexports.version = '5.7.1';\nexports[\"default\"] = {\n    parse: parse,\n    parseModule: parseModule,\n    parseScript: parseScript,\n    tokenize: tokenize,\n    Syntax: syntax_1.Syntax,\n    version: exports.version\n};\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/esprima.js?");

/***/ }),

/***/ "./dist/tsc/cjs/jsx-nodes.js":
/*!***********************************!*\
  !*** ./dist/tsc/cjs/jsx-nodes.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSXText = exports.JSXSpreadAttribute = exports.JSXOpeningFragment = exports.JSXOpeningElement = exports.JSXNamespacedName = exports.JSXAttribute = exports.JSXMemberExpression = exports.JSXIdentifier = exports.JSXExpressionContainer = exports.JSXEmptyExpression = exports.JSXElement = exports.JSXClosingFragment = exports.JSXClosingElement = void 0;\nvar jsx_syntax_1 = __webpack_require__(/*! ./jsx-syntax */ \"./dist/tsc/cjs/jsx-syntax.js\");\nvar JSXClosingElement = /** @class */ (function () {\n    function JSXClosingElement(name) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;\n        this.name = name;\n    }\n    return JSXClosingElement;\n}());\nexports.JSXClosingElement = JSXClosingElement;\nvar JSXClosingFragment = /** @class */ (function () {\n    function JSXClosingFragment() {\n        this.type = jsx_syntax_1.JSXSyntax.JSXClosingFragment;\n    }\n    return JSXClosingFragment;\n}());\nexports.JSXClosingFragment = JSXClosingFragment;\nvar JSXElement = /** @class */ (function () {\n    function JSXElement(openingElement, children, closingElement) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXElement;\n        this.openingElement = openingElement;\n        this.children = children;\n        this.closingElement = closingElement;\n    }\n    return JSXElement;\n}());\nexports.JSXElement = JSXElement;\nvar JSXEmptyExpression = /** @class */ (function () {\n    function JSXEmptyExpression() {\n        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;\n    }\n    return JSXEmptyExpression;\n}());\nexports.JSXEmptyExpression = JSXEmptyExpression;\nvar JSXExpressionContainer = /** @class */ (function () {\n    function JSXExpressionContainer(expression) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;\n        this.expression = expression;\n    }\n    return JSXExpressionContainer;\n}());\nexports.JSXExpressionContainer = JSXExpressionContainer;\nvar JSXIdentifier = /** @class */ (function () {\n    function JSXIdentifier(name) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;\n        this.name = name;\n    }\n    return JSXIdentifier;\n}());\nexports.JSXIdentifier = JSXIdentifier;\nvar JSXMemberExpression = /** @class */ (function () {\n    function JSXMemberExpression(object, property) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;\n        this.object = object;\n        this.property = property;\n    }\n    return JSXMemberExpression;\n}());\nexports.JSXMemberExpression = JSXMemberExpression;\nvar JSXAttribute = /** @class */ (function () {\n    function JSXAttribute(name, value) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;\n        this.name = name;\n        this.value = value;\n    }\n    return JSXAttribute;\n}());\nexports.JSXAttribute = JSXAttribute;\nvar JSXNamespacedName = /** @class */ (function () {\n    function JSXNamespacedName(namespace, name) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;\n        this.namespace = namespace;\n        this.name = name;\n    }\n    return JSXNamespacedName;\n}());\nexports.JSXNamespacedName = JSXNamespacedName;\nvar JSXOpeningElement = /** @class */ (function () {\n    function JSXOpeningElement(name, selfClosing, attributes) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;\n        this.name = name;\n        this.selfClosing = selfClosing;\n        this.attributes = attributes;\n    }\n    return JSXOpeningElement;\n}());\nexports.JSXOpeningElement = JSXOpeningElement;\nvar JSXOpeningFragment = /** @class */ (function () {\n    function JSXOpeningFragment(selfClosing) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningFragment;\n        this.selfClosing = selfClosing;\n    }\n    return JSXOpeningFragment;\n}());\nexports.JSXOpeningFragment = JSXOpeningFragment;\nvar JSXSpreadAttribute = /** @class */ (function () {\n    function JSXSpreadAttribute(argument) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;\n        this.argument = argument;\n    }\n    return JSXSpreadAttribute;\n}());\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nvar JSXText = /** @class */ (function () {\n    function JSXText(value, raw) {\n        this.type = jsx_syntax_1.JSXSyntax.JSXText;\n        this.value = value;\n        this.raw = raw;\n    }\n    return JSXText;\n}());\nexports.JSXText = JSXText;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/jsx-nodes.js?");

/***/ }),

/***/ "./dist/tsc/cjs/jsx-parser.js":
/*!************************************!*\
  !*** ./dist/tsc/cjs/jsx-parser.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* istanbul ignore next */
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSXParser = void 0;\nvar character_1 = __webpack_require__(/*! ./character */ \"./dist/tsc/cjs/character.js\");\nvar JSXNode = __webpack_require__(/*! ./jsx-nodes */ \"./dist/tsc/cjs/jsx-nodes.js\");\nvar jsx_syntax_1 = __webpack_require__(/*! ./jsx-syntax */ \"./dist/tsc/cjs/jsx-syntax.js\");\nvar Node = __webpack_require__(/*! ./nodes */ \"./dist/tsc/cjs/nodes.js\");\nvar parser_1 = __webpack_require__(/*! ./parser */ \"./dist/tsc/cjs/parser.js\");\nvar token_1 = __webpack_require__(/*! ./token */ \"./dist/tsc/cjs/token.js\");\nvar xhtml_entities_1 = __webpack_require__(/*! ./xhtml-entities */ \"./dist/tsc/cjs/xhtml-entities.js\");\ntoken_1.TokenName[100 /* JSXToken.Identifier */] = 'JSXIdentifier';\ntoken_1.TokenName[101 /* JSXToken.Text */] = 'JSXText';\n// Fully qualified element name, e.g. <svg:path> returns \"svg:path\"\nfunction getQualifiedElementName(elementName) {\n    var qualifiedName;\n    switch (elementName.type) {\n        case jsx_syntax_1.JSXSyntax.JSXIdentifier:\n            var id = elementName;\n            qualifiedName = id.name;\n            break;\n        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:\n            var ns = elementName;\n            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +\n                getQualifiedElementName(ns.name);\n            break;\n        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:\n            var expr = elementName;\n            qualifiedName = getQualifiedElementName(expr.object) + '.' +\n                getQualifiedElementName(expr.property);\n            break;\n        /* istanbul ignore next */\n        default:\n            break;\n    }\n    return qualifiedName;\n}\nvar JSXParser = /** @class */ (function (_super) {\n    __extends(JSXParser, _super);\n    function JSXParser(code, options, delegate) {\n        return _super.call(this, code, options, delegate) || this;\n    }\n    //@ts-ignore\n    JSXParser.prototype.parsePrimaryExpression = function () {\n        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);\n    };\n    JSXParser.prototype.startJSX = function () {\n        // Unwind the scanner before the lookahead token.\n        this.scanner.index = this.startMarker.index;\n        this.scanner.lineNumber = this.startMarker.line;\n        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;\n    };\n    JSXParser.prototype.finishJSX = function () {\n        // Prime the next lookahead.\n        this.nextToken();\n    };\n    JSXParser.prototype.reenterJSX = function () {\n        this.startJSX();\n        this.expectJSX('}');\n        // Pop the closing '}' added from the lookahead.\n        if (this.config.tokens) {\n            this.tokens.pop();\n        }\n    };\n    JSXParser.prototype.createJSXNode = function () {\n        this.collectComments();\n        return {\n            index: this.scanner.index,\n            line: this.scanner.lineNumber,\n            column: this.scanner.index - this.scanner.lineStart\n        };\n    };\n    JSXParser.prototype.createJSXChildNode = function () {\n        return {\n            index: this.scanner.index,\n            line: this.scanner.lineNumber,\n            column: this.scanner.index - this.scanner.lineStart\n        };\n    };\n    JSXParser.prototype.scanXHTMLEntity = function (quote) {\n        var result = '&';\n        var valid = true;\n        var terminated = false;\n        var numeric = false;\n        var hex = false;\n        while (!this.scanner.eof() && valid && !terminated) {\n            var ch = this.scanner.source[this.scanner.index];\n            if (ch === quote) {\n                break;\n            }\n            terminated = (ch === ';');\n            result += ch;\n            ++this.scanner.index;\n            if (!terminated) {\n                switch (result.length) {\n                    case 2:\n                        // e.g. '&#123;'\n                        numeric = (ch === '#');\n                        break;\n                    case 3:\n                        if (numeric) {\n                            // e.g. '&#x41;'\n                            hex = (ch === 'x');\n                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));\n                            numeric = numeric && !hex;\n                        }\n                        break;\n                    default:\n                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));\n                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));\n                        break;\n                }\n            }\n        }\n        if (valid && terminated && result.length > 2) {\n            // e.g. '&#x41;' becomes just '#x41'\n            var str = result.substr(1, result.length - 2);\n            if (numeric && str.length > 1) {\n                result = String.fromCharCode(parseInt(str.substr(1), 10));\n            }\n            else if (hex && str.length > 2) {\n                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));\n            }\n            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {\n                result = xhtml_entities_1.XHTMLEntities[str];\n            }\n        }\n        return result;\n    };\n    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.\n    JSXParser.prototype.lexJSX = function () {\n        var cp = this.scanner.source.charCodeAt(this.scanner.index);\n        // < > / : = { }\n        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {\n            var value = this.scanner.source[this.scanner.index++];\n            return {\n                type: 7 /* Token.Punctuator */,\n                value: value,\n                lineNumber: this.scanner.lineNumber,\n                lineStart: this.scanner.lineStart,\n                start: this.scanner.index - 1,\n                end: this.scanner.index\n            };\n        }\n        // \" '\n        if (cp === 34 || cp === 39) {\n            var start = this.scanner.index;\n            var quote = this.scanner.source[this.scanner.index++];\n            var str = '';\n            while (!this.scanner.eof()) {\n                var ch = this.scanner.source[this.scanner.index++];\n                if (ch === quote) {\n                    break;\n                }\n                else if (ch === '&') {\n                    str += this.scanXHTMLEntity(quote);\n                }\n                else {\n                    str += ch;\n                }\n            }\n            return {\n                type: 8 /* Token.StringLiteral */,\n                value: str,\n                lineNumber: this.scanner.lineNumber,\n                lineStart: this.scanner.lineStart,\n                start: start,\n                end: this.scanner.index\n            };\n        }\n        // ... or .\n        if (cp === 46) {\n            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);\n            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);\n            var value = (n1 === 46 && n2 === 46) ? '...' : '.';\n            var start = this.scanner.index;\n            this.scanner.index += value.length;\n            return {\n                type: 7 /* Token.Punctuator */,\n                value: value,\n                lineNumber: this.scanner.lineNumber,\n                lineStart: this.scanner.lineStart,\n                start: start,\n                end: this.scanner.index\n            };\n        }\n        // `\n        if (cp === 96) {\n            // Only placeholder, since it will be rescanned as a real assignment expression.\n            return {\n                type: 10 /* Token.Template */,\n                value: '',\n                lineNumber: this.scanner.lineNumber,\n                lineStart: this.scanner.lineStart,\n                start: this.scanner.index,\n                end: this.scanner.index\n            };\n        }\n        // Identifer can not contain backslash (char code 92).\n        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {\n            var start = this.scanner.index;\n            ++this.scanner.index;\n            while (!this.scanner.eof()) {\n                var ch = this.scanner.source.charCodeAt(this.scanner.index);\n                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {\n                    ++this.scanner.index;\n                }\n                else if (ch === 45) {\n                    // Hyphen (char code 45) can be part of an identifier.\n                    ++this.scanner.index;\n                }\n                else {\n                    break;\n                }\n            }\n            var id = this.scanner.source.slice(start, this.scanner.index);\n            return {\n                type: 100 /* JSXToken.Identifier */,\n                value: id,\n                lineNumber: this.scanner.lineNumber,\n                lineStart: this.scanner.lineStart,\n                start: start,\n                end: this.scanner.index\n            };\n        }\n        return this.scanner.lex();\n    };\n    JSXParser.prototype.nextJSXToken = function () {\n        this.collectComments();\n        this.startMarker.index = this.scanner.index;\n        this.startMarker.line = this.scanner.lineNumber;\n        this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n        var token = this.lexJSX();\n        this.lastMarker.index = this.scanner.index;\n        this.lastMarker.line = this.scanner.lineNumber;\n        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n        if (this.config.tokens) {\n            this.tokens.push(this.convertToken(token));\n        }\n        return token;\n    };\n    JSXParser.prototype.nextJSXText = function () {\n        this.startMarker.index = this.scanner.index;\n        this.startMarker.line = this.scanner.lineNumber;\n        this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n        var start = this.scanner.index;\n        var text = '';\n        while (!this.scanner.eof()) {\n            var ch = this.scanner.source[this.scanner.index];\n            if (ch === '{' || ch === '<') {\n                break;\n            }\n            ++this.scanner.index;\n            text += ch;\n            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n                ++this.scanner.lineNumber;\n                if (ch === '\\r' && this.scanner.source[this.scanner.index] === '\\n') {\n                    ++this.scanner.index;\n                }\n                this.scanner.lineStart = this.scanner.index;\n            }\n        }\n        this.lastMarker.index = this.scanner.index;\n        this.lastMarker.line = this.scanner.lineNumber;\n        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n        var token = {\n            type: 101 /* JSXToken.Text */,\n            value: text,\n            lineNumber: this.scanner.lineNumber,\n            lineStart: this.scanner.lineStart,\n            start: start,\n            end: this.scanner.index\n        };\n        if ((text.length > 0) && this.config.tokens) {\n            this.tokens.push(this.convertToken(token));\n        }\n        return token;\n    };\n    JSXParser.prototype.peekJSXToken = function () {\n        var state = this.scanner.saveState();\n        this.scanner.scanComments();\n        var next = this.lexJSX();\n        this.scanner.restoreState(state);\n        return next;\n    };\n    // Expect the next JSX token to match the specified punctuator.\n    // If not, an exception will be thrown.\n    JSXParser.prototype.expectJSX = function (value) {\n        var token = this.nextJSXToken();\n        if (token.type !== 7 /* Token.Punctuator */ || token.value !== value) {\n            this.throwUnexpectedToken(token);\n        }\n    };\n    // Return true if the next JSX token matches the specified punctuator.\n    JSXParser.prototype.matchJSX = function (value) {\n        var next = this.peekJSXToken();\n        return next.type === 7 /* Token.Punctuator */ && next.value === value;\n    };\n    JSXParser.prototype.parseJSXIdentifier = function () {\n        var node = this.createJSXNode();\n        var token = this.nextJSXToken();\n        if (token.type !== 100 /* JSXToken.Identifier */) {\n            this.throwUnexpectedToken(token);\n        }\n        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));\n    };\n    JSXParser.prototype.parseJSXElementName = function () {\n        var node = this.createJSXNode();\n        var elementName = this.parseJSXIdentifier();\n        if (this.matchJSX(':')) {\n            var namespace = elementName;\n            this.expectJSX(':');\n            var name_1 = this.parseJSXIdentifier();\n            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));\n        }\n        else if (this.matchJSX('.')) {\n            while (this.matchJSX('.')) {\n                var object = elementName;\n                this.expectJSX('.');\n                var property = this.parseJSXIdentifier();\n                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));\n            }\n        }\n        return elementName;\n    };\n    JSXParser.prototype.parseJSXAttributeName = function () {\n        var node = this.createJSXNode();\n        var attributeName;\n        var identifier = this.parseJSXIdentifier();\n        if (this.matchJSX(':')) {\n            var namespace = identifier;\n            this.expectJSX(':');\n            var name_2 = this.parseJSXIdentifier();\n            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));\n        }\n        else {\n            attributeName = identifier;\n        }\n        return attributeName;\n    };\n    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {\n        var node = this.createJSXNode();\n        var token = this.nextJSXToken();\n        if (token.type !== 8 /* Token.StringLiteral */) {\n            this.throwUnexpectedToken(token);\n        }\n        var raw = this.getTokenRaw(token);\n        return this.finalize(node, new Node.Literal(token.value, raw));\n    };\n    JSXParser.prototype.parseJSXExpressionAttribute = function () {\n        var node = this.createJSXNode();\n        this.expectJSX('{');\n        this.finishJSX();\n        if (this.match('}')) {\n            this.tolerateError('JSX attributes must only be assigned a non-empty expression');\n        }\n        var expression = this.parseAssignmentExpression();\n        this.reenterJSX();\n        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));\n    };\n    JSXParser.prototype.parseJSXAttributeValue = function () {\n        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :\n            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();\n    };\n    JSXParser.prototype.parseJSXNameValueAttribute = function () {\n        var node = this.createJSXNode();\n        var name = this.parseJSXAttributeName();\n        var value = null;\n        if (this.matchJSX('=')) {\n            this.expectJSX('=');\n            value = this.parseJSXAttributeValue();\n        }\n        return this.finalize(node, new JSXNode.JSXAttribute(name, value));\n    };\n    JSXParser.prototype.parseJSXSpreadAttribute = function () {\n        var node = this.createJSXNode();\n        this.expectJSX('{');\n        this.expectJSX('...');\n        this.finishJSX();\n        var argument = this.parseAssignmentExpression();\n        this.reenterJSX();\n        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));\n    };\n    JSXParser.prototype.parseJSXAttributes = function () {\n        var attributes = [];\n        while (!this.matchJSX('/') && !this.matchJSX('>')) {\n            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :\n                this.parseJSXNameValueAttribute();\n            attributes.push(attribute);\n        }\n        return attributes;\n    };\n    JSXParser.prototype.parseJSXOpeningElement = function () {\n        var node = this.createJSXNode();\n        this.expectJSX('<');\n        if (this.matchJSX('>')) {\n            this.expectJSX('>');\n            return this.finalize(node, new JSXNode.JSXOpeningFragment(false));\n        }\n        var name = this.parseJSXElementName();\n        var attributes = this.parseJSXAttributes();\n        var selfClosing = this.matchJSX('/');\n        if (selfClosing) {\n            this.expectJSX('/');\n        }\n        this.expectJSX('>');\n        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));\n    };\n    JSXParser.prototype.parseJSXBoundaryElement = function () {\n        var node = this.createJSXNode();\n        this.expectJSX('<');\n        if (this.matchJSX('/')) {\n            this.expectJSX('/');\n            if (this.matchJSX('>')) {\n                this.expectJSX('>');\n                return this.finalize(node, new JSXNode.JSXClosingFragment());\n            }\n            var elementName = this.parseJSXElementName();\n            this.expectJSX('>');\n            return this.finalize(node, new JSXNode.JSXClosingElement(elementName));\n        }\n        var name = this.parseJSXElementName();\n        var attributes = this.parseJSXAttributes();\n        var selfClosing = this.matchJSX('/');\n        if (selfClosing) {\n            this.expectJSX('/');\n        }\n        this.expectJSX('>');\n        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));\n    };\n    JSXParser.prototype.parseJSXEmptyExpression = function () {\n        var node = this.createJSXChildNode();\n        this.collectComments();\n        this.lastMarker.index = this.scanner.index;\n        this.lastMarker.line = this.scanner.lineNumber;\n        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n        return this.finalize(node, new JSXNode.JSXEmptyExpression());\n    };\n    JSXParser.prototype.parseJSXExpressionContainer = function () {\n        var node = this.createJSXNode();\n        this.expectJSX('{');\n        var expression;\n        if (this.matchJSX('}')) {\n            expression = this.parseJSXEmptyExpression();\n            this.expectJSX('}');\n        }\n        else {\n            this.finishJSX();\n            expression = this.parseAssignmentExpression();\n            this.reenterJSX();\n        }\n        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));\n    };\n    JSXParser.prototype.parseJSXChildren = function () {\n        var children = [];\n        while (!this.scanner.eof()) {\n            var node = this.createJSXChildNode();\n            var token = this.nextJSXText();\n            if (token.start < token.end) {\n                var raw = this.getTokenRaw(token);\n                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));\n                children.push(child);\n            }\n            if (this.scanner.source[this.scanner.index] === '{') {\n                var container = this.parseJSXExpressionContainer();\n                children.push(container);\n            }\n            else {\n                break;\n            }\n        }\n        return children;\n    };\n    JSXParser.prototype.parseComplexJSXElement = function (el) {\n        var stack = [];\n        while (!this.scanner.eof()) {\n            el.children = el.children.concat(this.parseJSXChildren());\n            var node = this.createJSXChildNode();\n            var element = this.parseJSXBoundaryElement();\n            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {\n                var opening = element;\n                if (opening.selfClosing) {\n                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));\n                    el.children.push(child);\n                }\n                else {\n                    stack.push(el);\n                    el = { node: node, opening: opening, closing: null, children: [] };\n                }\n            }\n            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {\n                el.closing = element;\n                var open_1 = getQualifiedElementName(el.opening.name);\n                var close_1 = getQualifiedElementName(el.closing.name);\n                if (open_1 !== close_1) {\n                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);\n                }\n                if (stack.length > 0) {\n                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));\n                    el = stack[stack.length - 1];\n                    el.children.push(child);\n                    stack.pop();\n                }\n                else {\n                    break;\n                }\n            }\n            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingFragment) {\n                el.closing = element;\n                if (el.opening.type !== jsx_syntax_1.JSXSyntax.JSXOpeningFragment) {\n                    this.tolerateError('Expected corresponding JSX closing tag for jsx fragment');\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return el;\n    };\n    JSXParser.prototype.parseJSXElement = function () {\n        var node = this.createJSXNode();\n        var opening = this.parseJSXOpeningElement();\n        var children = [];\n        var closing = null;\n        if (!opening.selfClosing) {\n            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });\n            children = el.children;\n            closing = el.closing;\n        }\n        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));\n    };\n    JSXParser.prototype.parseJSXRoot = function () {\n        // Pop the opening '<' added from the lookahead.\n        if (this.config.tokens) {\n            this.tokens.pop();\n        }\n        this.startJSX();\n        var element = this.parseJSXElement();\n        this.finishJSX();\n        return element;\n    };\n    JSXParser.prototype.isStartOfExpression = function () {\n        return _super.prototype.isStartOfExpression.call(this) || this.match('<');\n    };\n    return JSXParser;\n}(parser_1.Parser));\nexports.JSXParser = JSXParser;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/jsx-parser.js?");

/***/ }),

/***/ "./dist/tsc/cjs/jsx-syntax.js":
/*!************************************!*\
  !*** ./dist/tsc/cjs/jsx-syntax.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSXSyntax = void 0;\nvar JSXSyntax;\n(function (JSXSyntax) {\n    JSXSyntax[\"JSXAttribute\"] = \"JSXAttribute\";\n    JSXSyntax[\"JSXClosingElement\"] = \"JSXClosingElement\";\n    JSXSyntax[\"JSXClosingFragment\"] = \"JSXClosingFragment\";\n    JSXSyntax[\"JSXElement\"] = \"JSXElement\";\n    JSXSyntax[\"JSXEmptyExpression\"] = \"JSXEmptyExpression\";\n    JSXSyntax[\"JSXExpressionContainer\"] = \"JSXExpressionContainer\";\n    JSXSyntax[\"JSXIdentifier\"] = \"JSXIdentifier\";\n    JSXSyntax[\"JSXMemberExpression\"] = \"JSXMemberExpression\";\n    JSXSyntax[\"JSXNamespacedName\"] = \"JSXNamespacedName\";\n    JSXSyntax[\"JSXOpeningElement\"] = \"JSXOpeningElement\";\n    JSXSyntax[\"JSXOpeningFragment\"] = \"JSXOpeningFragment\";\n    JSXSyntax[\"JSXSpreadAttribute\"] = \"JSXSpreadAttribute\";\n    JSXSyntax[\"JSXText\"] = \"JSXText\";\n})(JSXSyntax = exports.JSXSyntax || (exports.JSXSyntax = {}));\n;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/jsx-syntax.js?");

/***/ }),

/***/ "./dist/tsc/cjs/messages.js":
/*!**********************************!*\
  !*** ./dist/tsc/cjs/messages.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Messages = void 0;\n// Error messages should be identical to V8.\nexports.Messages = {\n    AsyncFunctionInSingleStatementContext: 'Async functions can only be declared at the top level or inside a block.',\n    BadImportCallArity: 'Unexpected token',\n    BadGetterArity: 'Getter must not have any formal parameters',\n    BadSetterArity: 'Setter must have exactly one formal parameter',\n    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',\n    CannotUseImportMetaOutsideAModule: 'Cannot use \\'import.meta\\' outside a module',\n    ConstructorIsAsync: 'Class constructor may not be an async method',\n    ConstructorIsPrivate: 'Class constructor may not be a private method',\n    ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',\n    DefaultRestParameter: 'Unexpected token =',\n    DefaultRestProperty: 'Unexpected token =',\n    DuplicateBinding: 'Duplicate binding %0',\n    DuplicateConstructor: 'A class may only have one constructor',\n    DuplicateParameter: 'Duplicate parameter name not allowed in this context',\n    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',\n    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',\n    IllegalBreak: 'Illegal break statement',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalExportDeclaration: 'Unexpected token',\n    IllegalImportDeclaration: 'Unexpected token',\n    IllegalLanguageModeDirective: 'Illegal \\'use strict\\' directive in function with non-simple parameter list',\n    IllegalReturn: 'Illegal return statement',\n    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',\n    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n    InvalidModuleSpecifier: 'Unexpected token',\n    InvalidRegExp: 'Invalid regular expression',\n    InvalidTaggedTemplateOnOptionalChain: 'Invalid tagged template on optional chain',\n    InvalidUnicodeEscapeSequence: 'Invalid Unicode escape sequence',\n    LetInLexicalBinding: 'let is disallowed as a lexically bound name',\n    MissingFromClause: 'Unexpected token',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    NoAsAfterImportNamespace: 'Unexpected token',\n    NoAsAndFromEscapeSequences: 'The `as` and `from` contextual keywords must not contain Unicode escape sequences.',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    NoSemicolonAfterDecorator: \"Decorators must not be followed by a semicolon.\",\n    NumericSeperatorOneUnderscore: 'Numeric separator must be exactly one underscore',\n    NumericSeperatorNotAllowedHere: 'Numeric separator is not allowed here',\n    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n    PropertyAfterRestProperty: 'Unexpected token',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    StaticPrototype: 'Classes may not have static property named prototype',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n    TemplateEscape89: '\\\\8 and \\\\9 are not allowed in template strings.',\n    UnexpectedEOS: 'Unexpected end of input',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedSuper: '\\'super\\' keyword unexpected here',\n    UnexpectedTemplate: 'Unexpected quasi %0',\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    UnterminatedRegExp: 'Invalid regular expression: missing /'\n};\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/messages.js?");

/***/ }),

/***/ "./dist/tsc/cjs/nodes.js":
/*!*******************************!*\
  !*** ./dist/tsc/cjs/nodes.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NewExpression = exports.Module = exports.MethodDefinition = exports.MetaProperty = exports.MemberExpression = exports.LogicalExpression = exports.Literal = exports.LabeledStatement = exports.ImportSpecifier = exports.ImportNamespaceSpecifier = exports.ImportDefaultSpecifier = exports.ImportDeclaration = exports.ImportExpression = exports.ImportAttribute = exports.IfStatement = exports.Identifier = exports.FunctionExpression = exports.FunctionDeclaration = exports.ForStatement = exports.ForOfStatement = exports.ForInStatement = exports.ExpressionStatement = exports.ExportSpecifier = exports.ExportNamedDeclaration = exports.ExportDefaultDeclaration = exports.ExportAllDeclaration = exports.EmptyStatement = exports.DoWhileStatement = exports.Directive = exports.Decorator = exports.DebuggerStatement = exports.ContinueStatement = exports.ConditionalExpression = exports.ClassExpression = exports.ClassDeclaration = exports.ClassBody = exports.ChainExpression = exports.CatchClause = exports.CallExpression = exports.BreakStatement = exports.BlockStatement = exports.BinaryExpression = exports.BigIntLiteral = exports.AwaitExpression = exports.AsyncFunctionDeclaration = exports.AssignmentPattern = exports.AssignmentExpression = exports.ArrowFunctionExpression = exports.ArrayPattern = exports.ArrayExpression = void 0;\nexports.YieldExpression = exports.WithStatement = exports.WhileStatement = exports.VariableDeclarator = exports.VariableDeclaration = exports.UpdateExpression = exports.UnaryExpression = exports.TryStatement = exports.ThrowStatement = exports.ThisExpression = exports.TemplateLiteral = exports.TemplateElement = exports.TaggedTemplateExpression = exports.SwitchStatement = exports.SwitchCase = exports.Super = exports.StaticBlock = exports.SpreadElement = exports.SequenceExpression = exports.Script = exports.ReturnStatement = exports.RestElement = exports.RegexLiteral = exports.PropertyDefinition = exports.Property = exports.Program = exports.PrivateIdentifier = exports.ObjectPattern = exports.ObjectExpression = void 0;\nvar syntax_1 = __webpack_require__(/*! ./syntax */ \"./dist/tsc/cjs/syntax.js\");\nvar ArrayExpression = /** @class */ (function () {\n    function ArrayExpression(elements) {\n        this.type = syntax_1.Syntax.ArrayExpression;\n        this.elements = elements;\n    }\n    return ArrayExpression;\n}());\nexports.ArrayExpression = ArrayExpression;\nvar ArrayPattern = /** @class */ (function () {\n    function ArrayPattern(elements) {\n        this.type = syntax_1.Syntax.ArrayPattern;\n        this.elements = elements;\n    }\n    return ArrayPattern;\n}());\nexports.ArrayPattern = ArrayPattern;\nvar ArrowFunctionExpression = /** @class */ (function () {\n    function ArrowFunctionExpression(params, body, expression, isAsync) {\n        this.type = syntax_1.Syntax.ArrowFunctionExpression;\n        this.id = null;\n        this.params = params;\n        this.body = body;\n        this.generator = false;\n        this.expression = expression;\n        this.async = isAsync;\n    }\n    return ArrowFunctionExpression;\n}());\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nvar AssignmentExpression = /** @class */ (function () {\n    function AssignmentExpression(operator, left, right) {\n        this.type = syntax_1.Syntax.AssignmentExpression;\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n    return AssignmentExpression;\n}());\nexports.AssignmentExpression = AssignmentExpression;\nvar AssignmentPattern = /** @class */ (function () {\n    function AssignmentPattern(left, right) {\n        this.type = syntax_1.Syntax.AssignmentPattern;\n        this.left = left;\n        this.right = right;\n    }\n    return AssignmentPattern;\n}());\nexports.AssignmentPattern = AssignmentPattern;\nvar AsyncFunctionDeclaration = /** @class */ (function () {\n    function AsyncFunctionDeclaration(id, params, body, generator) {\n        this.type = syntax_1.Syntax.FunctionDeclaration;\n        this.id = id;\n        this.params = params;\n        this.body = body;\n        this.generator = generator;\n        this.expression = false;\n        this.async = true;\n    }\n    return AsyncFunctionDeclaration;\n}());\nexports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;\nvar AwaitExpression = /** @class */ (function () {\n    function AwaitExpression(argument) {\n        this.type = syntax_1.Syntax.AwaitExpression;\n        this.argument = argument;\n    }\n    return AwaitExpression;\n}());\nexports.AwaitExpression = AwaitExpression;\nvar BigIntLiteral = /** @class */ (function () {\n    function BigIntLiteral(value, raw, bigint) {\n        this.type = syntax_1.Syntax.Literal;\n        this.value = value;\n        this.raw = raw;\n        this.bigint = bigint;\n    }\n    return BigIntLiteral;\n}());\nexports.BigIntLiteral = BigIntLiteral;\nvar BinaryExpression = /** @class */ (function () {\n    function BinaryExpression(operator, left, right) {\n        this.type = syntax_1.Syntax.BinaryExpression;\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n    return BinaryExpression;\n}());\nexports.BinaryExpression = BinaryExpression;\nvar BlockStatement = /** @class */ (function () {\n    function BlockStatement(body) {\n        this.type = syntax_1.Syntax.BlockStatement;\n        this.body = body;\n    }\n    return BlockStatement;\n}());\nexports.BlockStatement = BlockStatement;\nvar BreakStatement = /** @class */ (function () {\n    function BreakStatement(label) {\n        this.type = syntax_1.Syntax.BreakStatement;\n        this.label = label;\n    }\n    return BreakStatement;\n}());\nexports.BreakStatement = BreakStatement;\nvar CallExpression = /** @class */ (function () {\n    function CallExpression(callee, args, optional) {\n        this.type = syntax_1.Syntax.CallExpression;\n        this.callee = callee;\n        this.arguments = args;\n        this.optional = optional;\n    }\n    return CallExpression;\n}());\nexports.CallExpression = CallExpression;\nvar CatchClause = /** @class */ (function () {\n    function CatchClause(param, body) {\n        this.type = syntax_1.Syntax.CatchClause;\n        this.param = param;\n        this.body = body;\n    }\n    return CatchClause;\n}());\nexports.CatchClause = CatchClause;\nvar ChainExpression = /** @class */ (function () {\n    function ChainExpression(expression) {\n        this.type = syntax_1.Syntax.ChainExpression;\n        this.expression = expression;\n    }\n    return ChainExpression;\n}());\nexports.ChainExpression = ChainExpression;\nvar ClassBody = /** @class */ (function () {\n    function ClassBody(body) {\n        this.type = syntax_1.Syntax.ClassBody;\n        this.body = body;\n    }\n    return ClassBody;\n}());\nexports.ClassBody = ClassBody;\nvar ClassDeclaration = /** @class */ (function () {\n    function ClassDeclaration(id, superClass, body, decorators) {\n        this.type = syntax_1.Syntax.ClassDeclaration;\n        this.id = id;\n        this.superClass = superClass;\n        this.body = body;\n        this.decorators = decorators;\n    }\n    return ClassDeclaration;\n}());\nexports.ClassDeclaration = ClassDeclaration;\nvar ClassExpression = /** @class */ (function () {\n    function ClassExpression(id, superClass, body, decorators) {\n        this.type = syntax_1.Syntax.ClassExpression;\n        this.id = id;\n        this.superClass = superClass;\n        this.body = body;\n        this.decorators = decorators;\n    }\n    return ClassExpression;\n}());\nexports.ClassExpression = ClassExpression;\nvar ConditionalExpression = /** @class */ (function () {\n    function ConditionalExpression(test, consequent, alternate) {\n        this.type = syntax_1.Syntax.ConditionalExpression;\n        this.test = test;\n        this.consequent = consequent;\n        this.alternate = alternate;\n    }\n    return ConditionalExpression;\n}());\nexports.ConditionalExpression = ConditionalExpression;\nvar ContinueStatement = /** @class */ (function () {\n    function ContinueStatement(label) {\n        this.type = syntax_1.Syntax.ContinueStatement;\n        this.label = label;\n    }\n    return ContinueStatement;\n}());\nexports.ContinueStatement = ContinueStatement;\nvar DebuggerStatement = /** @class */ (function () {\n    function DebuggerStatement() {\n        this.type = syntax_1.Syntax.DebuggerStatement;\n    }\n    return DebuggerStatement;\n}());\nexports.DebuggerStatement = DebuggerStatement;\nvar Decorator = /** @class */ (function () {\n    function Decorator(expression) {\n        this.type = syntax_1.Syntax.Decorator;\n        this.expression = expression;\n    }\n    return Decorator;\n}());\nexports.Decorator = Decorator;\nvar Directive = /** @class */ (function () {\n    function Directive(expression, directive) {\n        this.type = syntax_1.Syntax.ExpressionStatement;\n        this.expression = expression;\n        this.directive = directive;\n    }\n    return Directive;\n}());\nexports.Directive = Directive;\nvar DoWhileStatement = /** @class */ (function () {\n    function DoWhileStatement(body, test) {\n        this.type = syntax_1.Syntax.DoWhileStatement;\n        this.body = body;\n        this.test = test;\n    }\n    return DoWhileStatement;\n}());\nexports.DoWhileStatement = DoWhileStatement;\nvar EmptyStatement = /** @class */ (function () {\n    function EmptyStatement() {\n        this.type = syntax_1.Syntax.EmptyStatement;\n    }\n    return EmptyStatement;\n}());\nexports.EmptyStatement = EmptyStatement;\nvar ExportAllDeclaration = /** @class */ (function () {\n    function ExportAllDeclaration(source, exported, assertions) {\n        this.type = syntax_1.Syntax.ExportAllDeclaration;\n        this.source = source;\n        this.exported = exported;\n        this.assertions = assertions;\n    }\n    return ExportAllDeclaration;\n}());\nexports.ExportAllDeclaration = ExportAllDeclaration;\nvar ExportDefaultDeclaration = /** @class */ (function () {\n    function ExportDefaultDeclaration(declaration) {\n        this.type = syntax_1.Syntax.ExportDefaultDeclaration;\n        this.declaration = declaration;\n    }\n    return ExportDefaultDeclaration;\n}());\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nvar ExportNamedDeclaration = /** @class */ (function () {\n    function ExportNamedDeclaration(declaration, specifiers, source, assertions) {\n        this.type = syntax_1.Syntax.ExportNamedDeclaration;\n        this.declaration = declaration;\n        this.specifiers = specifiers;\n        this.source = source;\n        this.assertions = assertions;\n    }\n    return ExportNamedDeclaration;\n}());\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nvar ExportSpecifier = /** @class */ (function () {\n    function ExportSpecifier(local, exported) {\n        this.type = syntax_1.Syntax.ExportSpecifier;\n        this.exported = exported;\n        this.local = local;\n    }\n    return ExportSpecifier;\n}());\nexports.ExportSpecifier = ExportSpecifier;\nvar ExpressionStatement = /** @class */ (function () {\n    function ExpressionStatement(expression) {\n        this.type = syntax_1.Syntax.ExpressionStatement;\n        this.expression = expression;\n    }\n    return ExpressionStatement;\n}());\nexports.ExpressionStatement = ExpressionStatement;\nvar ForInStatement = /** @class */ (function () {\n    function ForInStatement(left, right, body) {\n        this.type = syntax_1.Syntax.ForInStatement;\n        this.left = left;\n        this.right = right;\n        this.body = body;\n        this.each = false;\n    }\n    return ForInStatement;\n}());\nexports.ForInStatement = ForInStatement;\nvar ForOfStatement = /** @class */ (function () {\n    function ForOfStatement(left, right, body, _await) {\n        this.type = syntax_1.Syntax.ForOfStatement;\n        this.await = _await;\n        this.left = left;\n        this.right = right;\n        this.body = body;\n    }\n    return ForOfStatement;\n}());\nexports.ForOfStatement = ForOfStatement;\nvar ForStatement = /** @class */ (function () {\n    function ForStatement(init, test, update, body) {\n        this.type = syntax_1.Syntax.ForStatement;\n        this.init = init;\n        this.test = test;\n        this.update = update;\n        this.body = body;\n    }\n    return ForStatement;\n}());\nexports.ForStatement = ForStatement;\nvar FunctionDeclaration = /** @class */ (function () {\n    function FunctionDeclaration(id, params, body, generator) {\n        this.type = syntax_1.Syntax.FunctionDeclaration;\n        this.id = id;\n        this.params = params;\n        this.body = body;\n        this.generator = generator;\n        this.expression = false;\n        this.async = false;\n    }\n    return FunctionDeclaration;\n}());\nexports.FunctionDeclaration = FunctionDeclaration;\nvar FunctionExpression = /** @class */ (function () {\n    function FunctionExpression(id, params, body, generator, isAsync) {\n        this.type = syntax_1.Syntax.FunctionExpression;\n        this.id = id;\n        this.params = params;\n        this.body = body;\n        this.generator = generator;\n        this.expression = false;\n        this.async = isAsync;\n    }\n    return FunctionExpression;\n}());\nexports.FunctionExpression = FunctionExpression;\nvar Identifier = /** @class */ (function () {\n    function Identifier(name) {\n        this.type = syntax_1.Syntax.Identifier;\n        this.name = name;\n    }\n    return Identifier;\n}());\nexports.Identifier = Identifier;\nvar IfStatement = /** @class */ (function () {\n    function IfStatement(test, consequent, alternate) {\n        this.type = syntax_1.Syntax.IfStatement;\n        this.test = test;\n        this.consequent = consequent;\n        this.alternate = alternate;\n    }\n    return IfStatement;\n}());\nexports.IfStatement = IfStatement;\nvar ImportAttribute = /** @class */ (function () {\n    function ImportAttribute(key, value) {\n        this.type = syntax_1.Syntax.ImportAttribute;\n        this.key = key;\n        this.value = value;\n    }\n    return ImportAttribute;\n}());\nexports.ImportAttribute = ImportAttribute;\nvar ImportExpression = /** @class */ (function () {\n    function ImportExpression(source, attributes) {\n        this.type = syntax_1.Syntax.ImportExpression;\n        this.source = source;\n        this.attributes = attributes;\n    }\n    return ImportExpression;\n}());\nexports.ImportExpression = ImportExpression;\nvar ImportDeclaration = /** @class */ (function () {\n    function ImportDeclaration(specifiers, source, assertions) {\n        this.type = syntax_1.Syntax.ImportDeclaration;\n        this.specifiers = specifiers;\n        this.source = source;\n        this.assertions = assertions;\n    }\n    return ImportDeclaration;\n}());\nexports.ImportDeclaration = ImportDeclaration;\nvar ImportDefaultSpecifier = /** @class */ (function () {\n    function ImportDefaultSpecifier(local) {\n        this.type = syntax_1.Syntax.ImportDefaultSpecifier;\n        this.local = local;\n    }\n    return ImportDefaultSpecifier;\n}());\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nvar ImportNamespaceSpecifier = /** @class */ (function () {\n    function ImportNamespaceSpecifier(local) {\n        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;\n        this.local = local;\n    }\n    return ImportNamespaceSpecifier;\n}());\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nvar ImportSpecifier = /** @class */ (function () {\n    function ImportSpecifier(local, imported) {\n        this.type = syntax_1.Syntax.ImportSpecifier;\n        this.local = local;\n        this.imported = imported;\n    }\n    return ImportSpecifier;\n}());\nexports.ImportSpecifier = ImportSpecifier;\nvar LabeledStatement = /** @class */ (function () {\n    function LabeledStatement(label, body) {\n        this.type = syntax_1.Syntax.LabeledStatement;\n        this.label = label;\n        this.body = body;\n    }\n    return LabeledStatement;\n}());\nexports.LabeledStatement = LabeledStatement;\nvar Literal = /** @class */ (function () {\n    function Literal(value, raw) {\n        this.type = syntax_1.Syntax.Literal;\n        this.value = value;\n        this.raw = raw;\n    }\n    return Literal;\n}());\nexports.Literal = Literal;\nvar LogicalExpression = /** @class */ (function () {\n    function LogicalExpression(operator, left, right) {\n        this.type = syntax_1.Syntax.LogicalExpression;\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n    return LogicalExpression;\n}());\nexports.LogicalExpression = LogicalExpression;\nvar MemberExpression = /** @class */ (function () {\n    function MemberExpression(computed, object, property, optional) {\n        this.type = syntax_1.Syntax.MemberExpression;\n        this.computed = computed;\n        this.object = object;\n        this.property = property;\n        this.optional = optional;\n    }\n    return MemberExpression;\n}());\nexports.MemberExpression = MemberExpression;\nvar MetaProperty = /** @class */ (function () {\n    function MetaProperty(meta, property) {\n        this.type = syntax_1.Syntax.MetaProperty;\n        this.meta = meta;\n        this.property = property;\n    }\n    return MetaProperty;\n}());\nexports.MetaProperty = MetaProperty;\nvar MethodDefinition = /** @class */ (function () {\n    function MethodDefinition(key, computed, value, kind, isStatic, decorators) {\n        this.type = syntax_1.Syntax.MethodDefinition;\n        this.key = key;\n        this.computed = computed;\n        this.value = value;\n        this.kind = kind;\n        this.static = isStatic;\n        this.decorators = decorators;\n    }\n    return MethodDefinition;\n}());\nexports.MethodDefinition = MethodDefinition;\nvar Module = /** @class */ (function () {\n    function Module(body) {\n        this.type = syntax_1.Syntax.Program;\n        this.body = body;\n        this.sourceType = 'module';\n    }\n    return Module;\n}());\nexports.Module = Module;\nvar NewExpression = /** @class */ (function () {\n    function NewExpression(callee, args) {\n        this.type = syntax_1.Syntax.NewExpression;\n        this.callee = callee;\n        this.arguments = args;\n    }\n    return NewExpression;\n}());\nexports.NewExpression = NewExpression;\nvar ObjectExpression = /** @class */ (function () {\n    function ObjectExpression(properties) {\n        this.type = syntax_1.Syntax.ObjectExpression;\n        this.properties = properties;\n    }\n    return ObjectExpression;\n}());\nexports.ObjectExpression = ObjectExpression;\nvar ObjectPattern = /** @class */ (function () {\n    function ObjectPattern(properties) {\n        this.type = syntax_1.Syntax.ObjectPattern;\n        this.properties = properties;\n    }\n    return ObjectPattern;\n}());\nexports.ObjectPattern = ObjectPattern;\nvar PrivateIdentifier = /** @class */ (function () {\n    function PrivateIdentifier(name) {\n        this.type = syntax_1.Syntax.PrivateIdentifier;\n        this.name = name;\n    }\n    return PrivateIdentifier;\n}());\nexports.PrivateIdentifier = PrivateIdentifier;\nvar Program = /** @class */ (function () {\n    function Program(sourceType, body) {\n        this.type = syntax_1.Syntax.Program;\n        this.sourceType = sourceType;\n        this.body = body;\n    }\n    return Program;\n}());\nexports.Program = Program;\nvar Property = /** @class */ (function () {\n    function Property(kind, key, computed, value, method, shorthand) {\n        this.type = syntax_1.Syntax.Property;\n        this.key = key;\n        this.computed = computed;\n        this.value = value;\n        this.kind = kind;\n        this.method = method;\n        this.shorthand = shorthand;\n    }\n    return Property;\n}());\nexports.Property = Property;\nvar PropertyDefinition = /** @class */ (function () {\n    function PropertyDefinition(key, computed, value, isStatic, decorators) {\n        this.type = syntax_1.Syntax.Property;\n        this.key = key;\n        this.computed = computed;\n        this.value = value;\n        this.static = isStatic;\n        this.decorators = decorators;\n    }\n    return PropertyDefinition;\n}());\nexports.PropertyDefinition = PropertyDefinition;\nvar RegexLiteral = /** @class */ (function () {\n    function RegexLiteral(value, raw, pattern, flags) {\n        this.type = syntax_1.Syntax.Literal;\n        this.value = value;\n        this.raw = raw;\n        this.regex = { pattern: pattern, flags: flags };\n    }\n    return RegexLiteral;\n}());\nexports.RegexLiteral = RegexLiteral;\nvar RestElement = /** @class */ (function () {\n    function RestElement(argument) {\n        this.type = syntax_1.Syntax.RestElement;\n        this.argument = argument;\n    }\n    return RestElement;\n}());\nexports.RestElement = RestElement;\nvar ReturnStatement = /** @class */ (function () {\n    function ReturnStatement(argument) {\n        this.type = syntax_1.Syntax.ReturnStatement;\n        this.argument = argument;\n    }\n    return ReturnStatement;\n}());\nexports.ReturnStatement = ReturnStatement;\nvar Script = /** @class */ (function () {\n    function Script(body) {\n        this.type = syntax_1.Syntax.Program;\n        this.body = body;\n        this.sourceType = 'script';\n    }\n    return Script;\n}());\nexports.Script = Script;\nvar SequenceExpression = /** @class */ (function () {\n    function SequenceExpression(expressions) {\n        this.type = syntax_1.Syntax.SequenceExpression;\n        this.expressions = expressions;\n    }\n    return SequenceExpression;\n}());\nexports.SequenceExpression = SequenceExpression;\nvar SpreadElement = /** @class */ (function () {\n    function SpreadElement(argument) {\n        this.type = syntax_1.Syntax.SpreadElement;\n        this.argument = argument;\n    }\n    return SpreadElement;\n}());\nexports.SpreadElement = SpreadElement;\nvar StaticBlock = /** @class */ (function () {\n    function StaticBlock(body) {\n        this.type = syntax_1.Syntax.StaticBlock;\n        this.body = body;\n    }\n    return StaticBlock;\n}());\nexports.StaticBlock = StaticBlock;\nvar Super = /** @class */ (function () {\n    function Super() {\n        this.type = syntax_1.Syntax.Super;\n    }\n    return Super;\n}());\nexports.Super = Super;\nvar SwitchCase = /** @class */ (function () {\n    function SwitchCase(test, consequent) {\n        this.type = syntax_1.Syntax.SwitchCase;\n        this.test = test;\n        this.consequent = consequent;\n    }\n    return SwitchCase;\n}());\nexports.SwitchCase = SwitchCase;\nvar SwitchStatement = /** @class */ (function () {\n    function SwitchStatement(discriminant, cases) {\n        this.type = syntax_1.Syntax.SwitchStatement;\n        this.discriminant = discriminant;\n        this.cases = cases;\n    }\n    return SwitchStatement;\n}());\nexports.SwitchStatement = SwitchStatement;\nvar TaggedTemplateExpression = /** @class */ (function () {\n    function TaggedTemplateExpression(tag, quasi) {\n        this.type = syntax_1.Syntax.TaggedTemplateExpression;\n        this.tag = tag;\n        this.quasi = quasi;\n    }\n    return TaggedTemplateExpression;\n}());\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nvar TemplateElement = /** @class */ (function () {\n    function TemplateElement(value, tail) {\n        this.type = syntax_1.Syntax.TemplateElement;\n        this.value = value;\n        this.tail = tail;\n    }\n    return TemplateElement;\n}());\nexports.TemplateElement = TemplateElement;\nvar TemplateLiteral = /** @class */ (function () {\n    function TemplateLiteral(quasis, expressions) {\n        this.type = syntax_1.Syntax.TemplateLiteral;\n        this.quasis = quasis;\n        this.expressions = expressions;\n    }\n    return TemplateLiteral;\n}());\nexports.TemplateLiteral = TemplateLiteral;\nvar ThisExpression = /** @class */ (function () {\n    function ThisExpression() {\n        this.type = syntax_1.Syntax.ThisExpression;\n    }\n    return ThisExpression;\n}());\nexports.ThisExpression = ThisExpression;\nvar ThrowStatement = /** @class */ (function () {\n    function ThrowStatement(argument) {\n        this.type = syntax_1.Syntax.ThrowStatement;\n        this.argument = argument;\n    }\n    return ThrowStatement;\n}());\nexports.ThrowStatement = ThrowStatement;\nvar TryStatement = /** @class */ (function () {\n    function TryStatement(block, handler, finalizer) {\n        this.type = syntax_1.Syntax.TryStatement;\n        this.block = block;\n        this.handler = handler;\n        this.finalizer = finalizer;\n    }\n    return TryStatement;\n}());\nexports.TryStatement = TryStatement;\nvar UnaryExpression = /** @class */ (function () {\n    function UnaryExpression(operator, argument) {\n        this.type = syntax_1.Syntax.UnaryExpression;\n        this.operator = operator;\n        this.argument = argument;\n        this.prefix = true;\n    }\n    return UnaryExpression;\n}());\nexports.UnaryExpression = UnaryExpression;\nvar UpdateExpression = /** @class */ (function () {\n    function UpdateExpression(operator, argument, prefix) {\n        this.type = syntax_1.Syntax.UpdateExpression;\n        this.operator = operator;\n        this.argument = argument;\n        this.prefix = prefix;\n    }\n    return UpdateExpression;\n}());\nexports.UpdateExpression = UpdateExpression;\nvar VariableDeclaration = /** @class */ (function () {\n    function VariableDeclaration(declarations, kind) {\n        this.type = syntax_1.Syntax.VariableDeclaration;\n        this.declarations = declarations;\n        this.kind = kind;\n    }\n    return VariableDeclaration;\n}());\nexports.VariableDeclaration = VariableDeclaration;\nvar VariableDeclarator = /** @class */ (function () {\n    function VariableDeclarator(id, init) {\n        this.type = syntax_1.Syntax.VariableDeclarator;\n        this.id = id;\n        this.init = init;\n    }\n    return VariableDeclarator;\n}());\nexports.VariableDeclarator = VariableDeclarator;\nvar WhileStatement = /** @class */ (function () {\n    function WhileStatement(test, body) {\n        this.type = syntax_1.Syntax.WhileStatement;\n        this.test = test;\n        this.body = body;\n    }\n    return WhileStatement;\n}());\nexports.WhileStatement = WhileStatement;\nvar WithStatement = /** @class */ (function () {\n    function WithStatement(object, body) {\n        this.type = syntax_1.Syntax.WithStatement;\n        this.object = object;\n        this.body = body;\n    }\n    return WithStatement;\n}());\nexports.WithStatement = WithStatement;\nvar YieldExpression = /** @class */ (function () {\n    function YieldExpression(argument, delegate) {\n        this.type = syntax_1.Syntax.YieldExpression;\n        this.argument = argument;\n        this.delegate = delegate;\n    }\n    return YieldExpression;\n}());\nexports.YieldExpression = YieldExpression;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/nodes.js?");

/***/ }),

/***/ "./dist/tsc/cjs/parser.js":
/*!********************************!*\
  !*** ./dist/tsc/cjs/parser.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nvar assert_1 = __webpack_require__(/*! ./assert */ \"./dist/tsc/cjs/assert.js\");\nvar character_1 = __webpack_require__(/*! ./character */ \"./dist/tsc/cjs/character.js\");\nvar error_handler_1 = __webpack_require__(/*! ./error-handler */ \"./dist/tsc/cjs/error-handler.js\");\nvar messages_1 = __webpack_require__(/*! ./messages */ \"./dist/tsc/cjs/messages.js\");\nvar Node = __webpack_require__(/*! ./nodes */ \"./dist/tsc/cjs/nodes.js\");\nvar scanner_1 = __webpack_require__(/*! ./scanner */ \"./dist/tsc/cjs/scanner.js\");\nvar syntax_1 = __webpack_require__(/*! ./syntax */ \"./dist/tsc/cjs/syntax.js\");\nvar token_1 = __webpack_require__(/*! ./token */ \"./dist/tsc/cjs/token.js\");\nvar ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';\n/* eslint-disable @typescript-eslint/unbound-method */\nvar Parser = /** @class */ (function () {\n    function Parser(code, options, delegate) {\n        if (options === void 0) { options = {}; }\n        this.config = {\n            range: (typeof options.range === 'boolean') && options.range,\n            loc: (typeof options.loc === 'boolean') && options.loc,\n            source: null,\n            tokens: (typeof options.tokens === 'boolean') && options.tokens,\n            comment: (typeof options.comment === 'boolean') && options.comment,\n            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant\n        };\n        if (this.config.loc && options.source && options.source !== null) {\n            this.config.source = String(options.source);\n        }\n        this.delegate = delegate;\n        this.errorHandler = new error_handler_1.ErrorHandler();\n        this.errorHandler.tolerant = this.config.tolerant == true;\n        this.scanner = new scanner_1.Scanner(code, this.errorHandler);\n        this.scanner.trackComment = this.config.comment == true;\n        this.operatorPrecedence = {\n            ')': 0,\n            ';': 0,\n            ',': 0,\n            '=': 0,\n            ']': 0,\n            '??': 5,\n            '||': 6,\n            '&&': 7,\n            '|': 8,\n            '^': 9,\n            '&': 10,\n            '==': 11,\n            '!=': 11,\n            '===': 11,\n            '!==': 11,\n            '<': 12,\n            '>': 12,\n            '<=': 12,\n            '>=': 12,\n            '<<': 13,\n            '>>': 13,\n            '>>>': 13,\n            '+': 14,\n            '-': 14,\n            '*': 15,\n            '/': 15,\n            '%': 15\n        };\n        this.lookahead = {\n            type: 2 /* Token.EOF */,\n            value: '',\n            lineNumber: this.scanner.lineNumber,\n            lineStart: 0,\n            start: 0,\n            end: 0\n        };\n        this.hasLineTerminator = false;\n        this.context = {\n            isModule: false,\n            isAsync: false,\n            allowIn: true,\n            allowStrictDirective: true,\n            allowSuper: false,\n            allowYield: true,\n            firstCoverInitializedNameError: null,\n            isAssignmentTarget: false,\n            isBindingElement: false,\n            inConstructor: false,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            inClassConstructor: false,\n            labelSet: {},\n            strict: false,\n            decorators: null\n        };\n        this.tokens = [];\n        this.startMarker = {\n            index: 0,\n            line: this.scanner.lineNumber,\n            column: 0\n        };\n        this.lastMarker = {\n            index: 0,\n            line: this.scanner.lineNumber,\n            column: 0\n        };\n        this.nextToken();\n        this.lastMarker = {\n            index: this.scanner.index,\n            line: this.scanner.lineNumber,\n            column: this.scanner.index - this.scanner.lineStart\n        };\n    }\n    Parser.prototype.throwError = function (messageFormat) {\n        var values = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            values[_i - 1] = arguments[_i];\n        }\n        var args = values.slice();\n        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n            (0, assert_1.assert)(idx < args.length, 'Message reference must be in range');\n            return args[idx];\n        });\n        var index = this.lastMarker.index;\n        var line = this.lastMarker.line;\n        var column = this.lastMarker.column + 1;\n        throw this.errorHandler.createError(index, line, column, msg);\n    };\n    Parser.prototype.tolerateError = function (messageFormat) {\n        var values = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            values[_i - 1] = arguments[_i];\n        }\n        var args = values.slice();\n        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n            (0, assert_1.assert)(idx < args.length, 'Message reference must be in range');\n            return args[idx];\n        });\n        var index = this.lastMarker.index;\n        var line = this.scanner.lineNumber;\n        var column = this.lastMarker.column + 1;\n        this.errorHandler.tolerateError(index, line, column, msg);\n    };\n    // Throw an exception because of the token.\n    Parser.prototype.unexpectedTokenError = function (token, message) {\n        var msg = message || messages_1.Messages.UnexpectedToken;\n        var value;\n        if (token) {\n            if (!message) {\n                msg = (token.type === 2 /* Token.EOF */) ? messages_1.Messages.UnexpectedEOS :\n                    (token.type === 3 /* Token.Identifier */) ? messages_1.Messages.UnexpectedIdentifier :\n                        (token.type === 6 /* Token.NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :\n                            (token.type === 8 /* Token.StringLiteral */) ? messages_1.Messages.UnexpectedString :\n                                (token.type === 10 /* Token.Template */) ? messages_1.Messages.UnexpectedTemplate :\n                                    messages_1.Messages.UnexpectedToken;\n                if (token.type === 4 /* Token.Keyword */) {\n                    if (this.scanner.isFutureReservedWord(token.value)) {\n                        msg = messages_1.Messages.UnexpectedReserved;\n                    }\n                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {\n                        msg = messages_1.Messages.StrictReservedWord;\n                    }\n                }\n            }\n            value = token.value;\n        }\n        else {\n            value = 'ILLEGAL';\n        }\n        msg = msg.replace('%0', value);\n        if (token && typeof token.lineNumber === 'number') {\n            var index = token.start;\n            var line = token.lineNumber;\n            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;\n            var column = token.start - lastMarkerLineStart + 1;\n            return this.errorHandler.createError(index, line, column, msg);\n        }\n        else {\n            var index = this.lastMarker.index;\n            var line = this.lastMarker.line;\n            var column = this.lastMarker.column + 1;\n            return this.errorHandler.createError(index, line, column, msg);\n        }\n    };\n    Parser.prototype.throwUnexpectedToken = function (token, message) {\n        throw this.unexpectedTokenError(token, message);\n    };\n    Parser.prototype.tolerateUnexpectedToken = function (token, message) {\n        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));\n    };\n    Parser.prototype.tolerateInvalidLoopStatement = function () {\n        if (this.matchKeyword(\"class\") || this.matchKeyword(\"function\")) {\n            this.tolerateError(messages_1.Messages.UnexpectedToken, this.lookahead);\n        }\n    };\n    Parser.prototype.collectComments = function () {\n        if (!this.config.comment) {\n            this.scanner.scanComments();\n        }\n        else {\n            var comments = this.scanner.scanComments();\n            if (comments.length > 0 && this.delegate) {\n                for (var i = 0; i < comments.length; ++i) {\n                    var e = comments[i];\n                    var node = {\n                        type: e.multiLine ? 'BlockComment' : 'LineComment',\n                        value: this.scanner.source.slice(e.slice[0], e.slice[1])\n                    };\n                    if (this.config.range) {\n                        node.range = e.range;\n                    }\n                    if (this.config.loc) {\n                        node.loc = e.loc;\n                    }\n                    var metadata = {\n                        start: {\n                            line: e.loc.start.line,\n                            column: e.loc.start.column,\n                            offset: e.range[0]\n                        },\n                        end: {\n                            line: e.loc.end.line,\n                            column: e.loc.end.column,\n                            offset: e.range[1]\n                        }\n                    };\n                    this.delegate(node, metadata);\n                }\n            }\n        }\n    };\n    // From internal representation to an external structure\n    Parser.prototype.getTokenRaw = function (token) {\n        return this.scanner.source.slice(token.start, token.end);\n    };\n    Parser.prototype.convertToken = function (token) {\n        var t = {\n            type: token_1.TokenName[token.type],\n            value: this.getTokenRaw(token)\n        };\n        if (this.config.range) {\n            t.range = [token.start, token.end];\n        }\n        if (this.config.loc) {\n            t.loc = {\n                start: {\n                    line: this.startMarker.line,\n                    column: this.startMarker.column\n                },\n                end: {\n                    line: this.scanner.lineNumber,\n                    column: this.scanner.index - this.scanner.lineStart\n                }\n            };\n        }\n        if (token.type === 9 /* Token.RegularExpression */) {\n            var pattern = token.pattern;\n            var flags = token.flags;\n            t.regex = { pattern: pattern, flags: flags };\n        }\n        return t;\n    };\n    Parser.prototype.nextToken = function () {\n        var token = this.lookahead;\n        this.lastMarker.index = this.scanner.index;\n        this.lastMarker.line = this.scanner.lineNumber;\n        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n        this.collectComments();\n        if (this.scanner.index !== this.startMarker.index) {\n            this.startMarker.index = this.scanner.index;\n            this.startMarker.line = this.scanner.lineNumber;\n            this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n        }\n        var next = this.scanner.lex();\n        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);\n        if (next && this.context.strict && next.type === 3 /* Token.Identifier */) {\n            if (this.scanner.isStrictModeReservedWord(next.value)) {\n                next.type = 4 /* Token.Keyword */;\n            }\n        }\n        this.lookahead = next;\n        if (this.config.tokens && next.type !== 2 /* Token.EOF */) {\n            this.tokens.push(this.convertToken(next));\n        }\n        return token;\n    };\n    Parser.prototype.nextRegexToken = function () {\n        this.collectComments();\n        var token = this.scanner.scanRegExp();\n        if (this.config.tokens) {\n            // Pop the previous token, '/' or '/='\n            // This is added from the lookahead token.\n            this.tokens.pop();\n            this.tokens.push(this.convertToken(token));\n        }\n        // Prime the next lookahead.\n        this.lookahead = token;\n        this.nextToken();\n        return token;\n    };\n    Parser.prototype.createNode = function () {\n        return {\n            index: this.startMarker.index,\n            line: this.startMarker.line,\n            column: this.startMarker.column\n        };\n    };\n    Parser.prototype.startNode = function (token, lastLineStart) {\n        if (lastLineStart === void 0) { lastLineStart = 0; }\n        var column = token.start - token.lineStart;\n        var line = token.lineNumber;\n        if (column < 0) {\n            column += lastLineStart;\n            line--;\n        }\n        return {\n            index: token.start,\n            line: line,\n            column: column\n        };\n    };\n    Parser.prototype.finalize = function (marker, node) {\n        if (this.config.range) {\n            node.range = [marker.index, this.lastMarker.index];\n        }\n        if (this.config.loc) {\n            node.loc = {\n                start: {\n                    line: marker.line,\n                    column: marker.column,\n                },\n                end: {\n                    line: this.lastMarker.line,\n                    column: this.lastMarker.column\n                }\n            };\n            if (this.config.source) {\n                node.loc.source = this.config.source;\n            }\n        }\n        if (this.delegate) {\n            var metadata = {\n                start: {\n                    line: marker.line,\n                    column: marker.column,\n                    offset: marker.index\n                },\n                end: {\n                    line: this.lastMarker.line,\n                    column: this.lastMarker.column,\n                    offset: this.lastMarker.index\n                }\n            };\n            this.delegate(node, metadata);\n        }\n        return node;\n    };\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n    Parser.prototype.expect = function (value) {\n        var token = this.nextToken();\n        if (token.type !== 7 /* Token.Punctuator */ || token.value !== value) {\n            this.throwUnexpectedToken(token);\n        }\n    };\n    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().\n    Parser.prototype.expectCommaSeparator = function () {\n        if (this.config.tolerant) {\n            var token = this.lookahead;\n            if (token.type === 7 /* Token.Punctuator */ && token.value === ',') {\n                this.nextToken();\n            }\n            else if (token.type === 7 /* Token.Punctuator */ && token.value === ';') {\n                this.nextToken();\n                this.tolerateUnexpectedToken(token);\n            }\n            else {\n                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);\n            }\n        }\n        else {\n            this.expect(',');\n        }\n    };\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n    Parser.prototype.expectKeyword = function (keyword) {\n        var token = this.nextToken();\n        if (token.type !== 4 /* Token.Keyword */ || token.value !== keyword) {\n            this.throwUnexpectedToken(token);\n        }\n    };\n    // Return true if the next token matches the specified punctuator.\n    Parser.prototype.match = function (value) {\n        return this.lookahead.type === 7 /* Token.Punctuator */ && this.lookahead.value === value;\n    };\n    // Return true if the next token matches the specified keyword\n    Parser.prototype.matchKeyword = function (keyword) {\n        return this.lookahead.type === 4 /* Token.Keyword */ && this.lookahead.value === keyword;\n    };\n    // Return true if the next token matches the specified contextual keyword\n    // (where an identifier is sometimes a keyword depending on the context)\n    Parser.prototype.matchContextualKeyword = function (keyword) {\n        return this.lookahead.type === 3 /* Token.Identifier */ && this.lookahead.value === keyword;\n    };\n    // Return true if the next token is an assignment operator\n    Parser.prototype.matchAssign = function () {\n        if (this.lookahead.type !== 7 /* Token.Punctuator */) {\n            return false;\n        }\n        var op = this.lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '**=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=' ||\n            op === '&&=' ||\n            op === '||=' ||\n            op === '??=';\n    };\n    // Cover grammar support.\n    //\n    // When an assignment expression position starts with an left parenthesis, the determination of the type\n    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n    //\n    // There are three productions that can be parsed in a parentheses pair that needs to be determined\n    // after the outermost pair is closed. They are:\n    //\n    //   1. AssignmentExpression\n    //   2. BindingElements\n    //   3. AssignmentTargets\n    //\n    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n    // binding element or assignment target.\n    //\n    // The three productions have the relationship:\n    //\n    //   BindingElements  AssignmentTargets  AssignmentExpression\n    //\n    // with a single exception that CoverInitializedName when used directly in an Expression, generates\n    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n    //\n    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n    // the CoverInitializedName check is conducted.\n    //\n    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n    // pattern. The CoverInitializedName check is deferred.\n    Parser.prototype.isolateCoverGrammar = function (parseFunction) {\n        var previousIsBindingElement = this.context.isBindingElement;\n        var previousIsAssignmentTarget = this.context.isAssignmentTarget;\n        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n        this.context.isBindingElement = true;\n        this.context.isAssignmentTarget = true;\n        this.context.firstCoverInitializedNameError = null;\n        var result = parseFunction.call(this);\n        if (this.context.firstCoverInitializedNameError !== null) {\n            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);\n        }\n        this.context.isBindingElement = previousIsBindingElement;\n        this.context.isAssignmentTarget = previousIsAssignmentTarget;\n        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;\n        return result;\n    };\n    Parser.prototype.inheritCoverGrammar = function (parseFunction) {\n        var previousIsBindingElement = this.context.isBindingElement;\n        var previousIsAssignmentTarget = this.context.isAssignmentTarget;\n        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n        this.context.isBindingElement = true;\n        this.context.isAssignmentTarget = true;\n        this.context.firstCoverInitializedNameError = null;\n        var result = parseFunction.call(this);\n        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;\n        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;\n        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;\n        return result;\n    };\n    Parser.prototype.consumeSemicolon = function () {\n        if (this.match(';')) {\n            this.nextToken();\n        }\n        else if (!this.hasLineTerminator) {\n            if (this.lookahead.type !== 2 /* Token.EOF */ && !this.match('}')) {\n                this.throwUnexpectedToken(this.lookahead);\n            }\n            this.lastMarker.index = this.startMarker.index;\n            this.lastMarker.line = this.startMarker.line;\n            this.lastMarker.column = this.startMarker.column;\n        }\n    };\n    // https://tc39.github.io/ecma262/#sec-primary-expression\n    Parser.prototype.parsePrimaryExpression = function () {\n        var node = this.createNode();\n        var expr;\n        var token, raw;\n        switch (this.lookahead.type) {\n            case 3 /* Token.Identifier */:\n                if ((this.context.isModule || this.context.isAsync) && this.lookahead.value === 'await') {\n                    this.tolerateUnexpectedToken(this.lookahead);\n                }\n                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));\n                break;\n            case 6 /* Token.NumericLiteral */:\n            case 8 /* Token.StringLiteral */:\n                if (this.context.strict && this.lookahead.octal) {\n                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);\n                }\n                this.context.isAssignmentTarget = false;\n                this.context.isBindingElement = false;\n                token = this.nextToken();\n                raw = this.getTokenRaw(token);\n                if (typeof token.value === 'bigint')\n                    expr = this.finalize(node, new Node.BigIntLiteral(token.value, raw, token.value.toString()));\n                else\n                    expr = this.finalize(node, new Node.Literal(token.value, raw));\n                break;\n            case 1 /* Token.BooleanLiteral */:\n                this.context.isAssignmentTarget = false;\n                this.context.isBindingElement = false;\n                token = this.nextToken();\n                raw = this.getTokenRaw(token);\n                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));\n                break;\n            case 5 /* Token.NullLiteral */:\n                this.context.isAssignmentTarget = false;\n                this.context.isBindingElement = false;\n                token = this.nextToken();\n                raw = this.getTokenRaw(token);\n                expr = this.finalize(node, new Node.Literal(null, raw));\n                break;\n            case 10 /* Token.Template */:\n                expr = this.parseTemplateLiteral({ isTagged: false });\n                break;\n            case 7 /* Token.Punctuator */:\n                switch (this.lookahead.value) {\n                    case '(':\n                        this.context.isBindingElement = false;\n                        expr = this.inheritCoverGrammar(this.parseGroupExpression);\n                        break;\n                    case '[':\n                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);\n                        break;\n                    case '{':\n                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);\n                        break;\n                    case '/':\n                    case '/=':\n                        this.context.isAssignmentTarget = false;\n                        this.context.isBindingElement = false;\n                        this.scanner.index = this.startMarker.index;\n                        token = this.nextRegexToken();\n                        raw = this.getTokenRaw(token);\n                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));\n                        break;\n                    case '#':\n                        this.nextToken();\n                        expr = this.finalize(node, new Node.PrivateIdentifier(this.nextToken().value));\n                        break;\n                    case \"@\":\n                        var decorators = this.parseDecorators();\n                        this.context.decorators = decorators;\n                        var expression = this.parsePrimaryExpression();\n                        this.context.decorators = null;\n                        expr = this.finalize(node, new Node.PrivateIdentifier(this.nextToken().value));\n                        break;\n                    default:\n                        expr = this.throwUnexpectedToken(this.nextToken());\n                }\n                break;\n            case 4 /* Token.Keyword */:\n                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {\n                    expr = this.parseIdentifierName();\n                }\n                else if (!this.context.strict && this.matchKeyword('let')) {\n                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));\n                }\n                else {\n                    this.context.isAssignmentTarget = false;\n                    this.context.isBindingElement = false;\n                    if (this.matchKeyword('function')) {\n                        expr = this.parseFunctionExpression();\n                    }\n                    else if (this.matchKeyword('this')) {\n                        this.nextToken();\n                        expr = this.finalize(node, new Node.ThisExpression());\n                    }\n                    else if (this.matchKeyword('class')) {\n                        expr = this.parseClassExpression();\n                    }\n                    else if (this.matchKeyword('new')) {\n                        expr = this.parseNewExpression();\n                    }\n                    else if (this.matchImportCall()) {\n                        expr = this.parseImportCall();\n                    }\n                    else if (this.matchImportMeta()) {\n                        if (!this.context.isModule) {\n                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.CannotUseImportMetaOutsideAModule);\n                        }\n                        expr = this.parseImportMeta();\n                    }\n                    else {\n                        expr = this.throwUnexpectedToken(this.nextToken());\n                    }\n                }\n                break;\n            default:\n                expr = this.throwUnexpectedToken(this.nextToken());\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-array-initializer\n    Parser.prototype.parseSpreadElement = function () {\n        var node = this.createNode();\n        this.expect('...');\n        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);\n        return this.finalize(node, new Node.SpreadElement(arg));\n    };\n    Parser.prototype.parseArrayInitializer = function () {\n        var node = this.createNode();\n        var elements = [];\n        this.expect('[');\n        while (!this.match(']')) {\n            if (this.match(',')) {\n                this.nextToken();\n                elements.push(null);\n            }\n            else if (this.match('...')) {\n                var element = this.parseSpreadElement();\n                if (!this.match(']')) {\n                    this.context.isAssignmentTarget = false;\n                    this.context.isBindingElement = false;\n                    this.expect(',');\n                }\n                elements.push(element);\n            }\n            else {\n                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\n                if (!this.match(']')) {\n                    this.expect(',');\n                }\n            }\n        }\n        this.expect(']');\n        return this.finalize(node, new Node.ArrayExpression(elements));\n    };\n    // https://tc39.github.io/ecma262/#sec-object-initializer\n    Parser.prototype.parsePropertyMethod = function (params) {\n        this.context.isAssignmentTarget = false;\n        this.context.isBindingElement = false;\n        var previousStrict = this.context.strict;\n        var previousAllowStrictDirective = this.context.allowStrictDirective;\n        this.context.allowStrictDirective = params.simple;\n        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);\n        if (this.context.strict && params.firstRestricted) {\n            this.tolerateUnexpectedToken(params.firstRestricted, params.message);\n        }\n        if (this.context.strict && params.stricted) {\n            this.tolerateUnexpectedToken(params.stricted, params.message);\n        }\n        this.context.strict = previousStrict;\n        this.context.allowStrictDirective = previousAllowStrictDirective;\n        return body;\n    };\n    Parser.prototype.parsePropertyMethodFunction = function (isGenerator) {\n        var node = this.createNode();\n        var previousAllowYield = this.context.allowYield;\n        this.context.allowYield = true;\n        var params = this.parseFormalParameters();\n        var method = this.parsePropertyMethod(params);\n        this.context.allowYield = previousAllowYield;\n        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator, false));\n    };\n    Parser.prototype.parsePropertyMethodAsyncFunction = function (isGenerator) {\n        var node = this.createNode();\n        var previousAllowYield = this.context.allowYield;\n        var previousIsAsync = this.context.isAsync;\n        this.context.allowYield = false;\n        this.context.isAsync = true;\n        var params = this.parseFormalParameters();\n        var method = this.parsePropertyMethod(params);\n        this.context.allowYield = previousAllowYield;\n        this.context.isAsync = previousIsAsync;\n        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator, true));\n    };\n    Parser.prototype.parseObjectPropertyKey = function (isPrivate) {\n        if (isPrivate === void 0) { isPrivate = false; }\n        var node = this.createNode();\n        var token = this.nextToken();\n        var key;\n        switch (token.type) {\n            case 8 /* Token.StringLiteral */:\n            case 6 /* Token.NumericLiteral */:\n                if (this.context.strict && token.octal) {\n                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);\n                }\n                var raw = this.getTokenRaw(token);\n                if (typeof token.value === 'bigint')\n                    key = this.finalize(node, new Node.BigIntLiteral(token.value, raw, token.value.toString()));\n                else\n                    key = this.finalize(node, new Node.Literal(token.value, raw));\n                break;\n            case 3 /* Token.Identifier */:\n            case 1 /* Token.BooleanLiteral */:\n            case 5 /* Token.NullLiteral */:\n            case 4 /* Token.Keyword */:\n                key = this.finalize(node, isPrivate ? new Node.PrivateIdentifier(token.value) : new Node.Identifier(token.value));\n                break;\n            case 7 /* Token.Punctuator */:\n                if (token.value === '[') {\n                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);\n                    this.expect(']');\n                }\n                else {\n                    key = this.throwUnexpectedToken(token);\n                }\n                break;\n            default:\n                key = this.throwUnexpectedToken(token);\n        }\n        return key;\n    };\n    Parser.prototype.isPropertyKey = function (key, value) {\n        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||\n            (key.type === syntax_1.Syntax.Literal && key.value === value);\n    };\n    Parser.prototype.parseObjectProperty = function (hasProto) {\n        var node = this.createNode();\n        var token = this.lookahead;\n        var kind;\n        var key = null;\n        var value = null;\n        var computed = false;\n        var method = false;\n        var shorthand = false;\n        var isAsync = false;\n        var isGenerator = false;\n        if (token.type === 3 /* Token.Identifier */) {\n            var id = token.value;\n            this.nextToken();\n            computed = this.match('[');\n            isAsync = !this.hasLineTerminator && (id === 'async') &&\n                !this.match(':') && !this.match('(') && !this.match(',');\n            isGenerator = this.match('*');\n            if (isGenerator) {\n                this.nextToken();\n            }\n            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));\n        }\n        else if (this.match('*')) {\n            this.nextToken();\n        }\n        else {\n            computed = this.match('[');\n            key = this.parseObjectPropertyKey();\n        }\n        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\n        if (token.type === 3 /* Token.Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {\n            kind = 'get';\n            computed = this.match('[');\n            key = this.parseObjectPropertyKey();\n            this.context.allowYield = false;\n            value = this.parseGetterMethod();\n        }\n        else if (token.type === 3 /* Token.Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {\n            kind = 'set';\n            computed = this.match('[');\n            key = this.parseObjectPropertyKey();\n            value = this.parseSetterMethod();\n        }\n        else if (token.type === 7 /* Token.Punctuator */ && token.value === '*' && lookaheadPropertyKey) {\n            kind = 'init';\n            computed = this.match('[');\n            key = this.parseObjectPropertyKey();\n            value = this.parseGeneratorMethod(false);\n            method = true;\n        }\n        else {\n            if (!key) {\n                this.throwUnexpectedToken(this.lookahead);\n            }\n            kind = 'init';\n            if (this.match(':') && !isAsync) {\n                if (!computed && this.isPropertyKey(key, '__proto__')) {\n                    if (hasProto.value) {\n                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);\n                    }\n                    hasProto.value = true;\n                }\n                this.nextToken();\n                value = this.inheritCoverGrammar(this.parseAssignmentExpression);\n            }\n            else if (this.match('(')) {\n                value = isAsync ? this.parsePropertyMethodAsyncFunction(isGenerator) : this.parsePropertyMethodFunction(isGenerator);\n                method = true;\n            }\n            else if (token.type === 3 /* Token.Identifier */) {\n                var id = this.finalize(node, new Node.Identifier(token.value));\n                if (this.match('=')) {\n                    this.context.firstCoverInitializedNameError = this.lookahead;\n                    this.nextToken();\n                    shorthand = true;\n                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n                    value = this.finalize(node, new Node.AssignmentPattern(id, init));\n                }\n                else {\n                    shorthand = true;\n                    value = id;\n                }\n            }\n            else {\n                this.throwUnexpectedToken(this.nextToken());\n            }\n        }\n        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));\n    };\n    Parser.prototype.parseObjectInitializer = function () {\n        var node = this.createNode();\n        this.expect('{');\n        var properties = [];\n        var hasProto = { value: false };\n        while (!this.match('}')) {\n            var property = this.match('...') ? this.parseSpreadElement() : this.parseObjectProperty(hasProto);\n            properties.push(property);\n            if (!this.match('}') && (!property.method || this.match(','))) {\n                this.expectCommaSeparator();\n            }\n        }\n        this.expect('}');\n        return this.finalize(node, new Node.ObjectExpression(properties));\n    };\n    // https://tc39.es/proposal-template-literal-revision/#sec-static-semantics-template-early-errors\n    Parser.prototype.throwTemplateLiteralEarlyErrors = function (token) {\n        switch (token.notEscapeSequenceHead) {\n            case 'u':\n                return this.throwUnexpectedToken(token, messages_1.Messages.InvalidUnicodeEscapeSequence);\n            case 'x':\n                return this.throwUnexpectedToken(token, messages_1.Messages.InvalidHexEscapeSequence);\n            case '8':\n            case '9':\n                return this.throwUnexpectedToken(token, messages_1.Messages.TemplateEscape89);\n            default: // For 0-7\n                return this.throwUnexpectedToken(token, messages_1.Messages.TemplateOctalLiteral);\n        }\n    };\n    // https://tc39.github.io/ecma262/#sec-template-literals\n    Parser.prototype.parseTemplateHead = function (options) {\n        (0, assert_1.assert)(this.lookahead.head, 'Template literal must start with a template head');\n        var node = this.createNode();\n        var token = this.nextToken();\n        if (!options.isTagged && token.notEscapeSequenceHead !== null) {\n            this.throwTemplateLiteralEarlyErrors(token);\n        }\n        var raw = token.value;\n        var cooked = token.cooked;\n        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));\n    };\n    Parser.prototype.parseTemplateElement = function (options) {\n        if (this.lookahead.type !== 10 /* Token.Template */) {\n            this.throwUnexpectedToken();\n        }\n        var node = this.createNode();\n        var token = this.nextToken();\n        if (!options.isTagged && token.notEscapeSequenceHead !== null) {\n            this.throwTemplateLiteralEarlyErrors(token);\n        }\n        var raw = token.value;\n        var cooked = token.cooked;\n        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));\n    };\n    Parser.prototype.parseTemplateLiteral = function (options) {\n        var node = this.createNode();\n        var expressions = [];\n        var quasis = [];\n        var quasi = this.parseTemplateHead(options);\n        quasis.push(quasi);\n        while (!quasi.tail) {\n            expressions.push(this.parseExpression());\n            quasi = this.parseTemplateElement(options);\n            quasis.push(quasi);\n        }\n        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));\n    };\n    // https://tc39.github.io/ecma262/#sec-grouping-operator\n    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {\n        switch (expr.type) {\n            case syntax_1.Syntax.Identifier:\n            case syntax_1.Syntax.MemberExpression:\n            case syntax_1.Syntax.RestElement:\n            case syntax_1.Syntax.AssignmentPattern:\n                break;\n            case syntax_1.Syntax.SpreadElement:\n                expr.type = syntax_1.Syntax.RestElement;\n                this.reinterpretExpressionAsPattern(expr.argument);\n                break;\n            case syntax_1.Syntax.ArrayExpression:\n                expr.type = syntax_1.Syntax.ArrayPattern;\n                for (var i = 0; i < expr.elements.length; i++) {\n                    if (expr.elements[i] !== null) {\n                        this.reinterpretExpressionAsPattern(expr.elements[i]);\n                    }\n                }\n                break;\n            case syntax_1.Syntax.ObjectExpression:\n                expr.type = syntax_1.Syntax.ObjectPattern;\n                for (var i = 0; i < expr.properties.length; i++) {\n                    var property = expr.properties[i];\n                    this.reinterpretExpressionAsPattern(property.type === syntax_1.Syntax.SpreadElement ? property : property.value);\n                }\n                break;\n            case syntax_1.Syntax.AssignmentExpression:\n                expr.type = syntax_1.Syntax.AssignmentPattern;\n                delete expr.operator;\n                this.reinterpretExpressionAsPattern(expr.left);\n                break;\n            default:\n                // Allow other node type for tolerant parsing.\n                break;\n        }\n    };\n    Parser.prototype.parseGroupExpression = function () {\n        var expr;\n        this.expect('(');\n        if (this.match(')')) {\n            this.nextToken();\n            if (!this.match('=>')) {\n                this.expect('=>');\n            }\n            expr = {\n                type: ArrowParameterPlaceHolder,\n                params: [],\n                async: false\n            };\n        }\n        else {\n            var startToken = this.lookahead;\n            var params = [];\n            if (this.match('...')) {\n                expr = this.parseRestElement(params);\n                this.expect(')');\n                if (!this.match('=>')) {\n                    this.expect('=>');\n                }\n                expr = {\n                    type: ArrowParameterPlaceHolder,\n                    params: [expr],\n                    async: false\n                };\n            }\n            else {\n                var arrow = false;\n                this.context.isBindingElement = true;\n                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);\n                if (this.match(',')) {\n                    var expressions = [];\n                    this.context.isAssignmentTarget = false;\n                    expressions.push(expr);\n                    while (this.lookahead.type !== 2 /* Token.EOF */) {\n                        if (!this.match(',')) {\n                            break;\n                        }\n                        this.nextToken();\n                        if (this.match(')')) {\n                            this.nextToken();\n                            for (var i = 0; i < expressions.length; i++) {\n                                this.reinterpretExpressionAsPattern(expressions[i]);\n                            }\n                            arrow = true;\n                            expr = {\n                                type: ArrowParameterPlaceHolder,\n                                params: expressions,\n                                async: false\n                            };\n                        }\n                        else if (this.match('...')) {\n                            if (!this.context.isBindingElement) {\n                                this.throwUnexpectedToken(this.lookahead);\n                            }\n                            expressions.push(this.parseRestElement(params));\n                            this.expect(')');\n                            if (!this.match('=>')) {\n                                this.expect('=>');\n                            }\n                            this.context.isBindingElement = false;\n                            for (var i = 0; i < expressions.length; i++) {\n                                this.reinterpretExpressionAsPattern(expressions[i]);\n                            }\n                            arrow = true;\n                            expr = {\n                                type: ArrowParameterPlaceHolder,\n                                params: expressions,\n                                async: false\n                            };\n                        }\n                        else {\n                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\n                        }\n                        if (arrow) {\n                            break;\n                        }\n                    }\n                    if (!arrow) {\n                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));\n                    }\n                }\n                if (!arrow) {\n                    this.expect(')');\n                    if (this.match('=>')) {\n                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {\n                            arrow = true;\n                            expr = {\n                                type: ArrowParameterPlaceHolder,\n                                params: [expr],\n                                async: false\n                            };\n                        }\n                        if (!arrow) {\n                            if (!this.context.isBindingElement) {\n                                this.throwUnexpectedToken(this.lookahead);\n                            }\n                            if (expr.type === syntax_1.Syntax.SequenceExpression) {\n                                for (var i = 0; i < expr.expressions.length; i++) {\n                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);\n                                }\n                            }\n                            else {\n                                this.reinterpretExpressionAsPattern(expr);\n                            }\n                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);\n                            expr = {\n                                type: ArrowParameterPlaceHolder,\n                                params: parameters,\n                                async: false\n                            };\n                        }\n                    }\n                    this.context.isBindingElement = false;\n                }\n            }\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions\n    Parser.prototype.parseArguments = function () {\n        this.expect('(');\n        var args = [];\n        if (!this.match(')')) {\n            while (true) {\n                var expr = this.match('...') ? this.parseSpreadElement() :\n                    this.isolateCoverGrammar(this.parseAssignmentExpression);\n                args.push(expr);\n                if (this.match(')')) {\n                    break;\n                }\n                this.expectCommaSeparator();\n                if (this.match(')')) {\n                    break;\n                }\n            }\n        }\n        this.expect(')');\n        return args;\n    };\n    Parser.prototype.isIdentifierName = function (token) {\n        return token.type === 3 /* Token.Identifier */ ||\n            token.type === 4 /* Token.Keyword */ ||\n            token.type === 1 /* Token.BooleanLiteral */ ||\n            token.type === 5 /* Token.NullLiteral */;\n    };\n    Parser.prototype.parseIdentifierName = function (allowPrivateField) {\n        if (allowPrivateField === void 0) { allowPrivateField = false; }\n        var isPrivateField = false;\n        var node = this.createNode();\n        var token = this.nextToken();\n        if (token.value === '#' && allowPrivateField) {\n            token = this.nextToken();\n            isPrivateField = true;\n        }\n        if (!this.isIdentifierName(token)) {\n            this.throwUnexpectedToken(token);\n        }\n        return this.finalize(node, isPrivateField ? new Node.PrivateIdentifier(token.value) : new Node.Identifier(token.value));\n    };\n    Parser.prototype.parseNewExpression = function () {\n        var node = this.createNode();\n        var id = this.parseIdentifierName();\n        (0, assert_1.assert)(id.name === 'new', 'New expression must start with `new`');\n        var expr;\n        if (this.match('.')) {\n            this.nextToken();\n            if (this.lookahead.type === 3 /* Token.Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {\n                var property = this.parseIdentifierName();\n                expr = new Node.MetaProperty(id, property);\n            }\n            else {\n                this.throwUnexpectedToken(this.lookahead);\n            }\n        }\n        else if (this.matchKeyword('import')) {\n            this.throwUnexpectedToken(this.lookahead);\n        }\n        else {\n            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);\n            var args = this.match('(') ? this.parseArguments() : [];\n            expr = new Node.NewExpression(callee, args);\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n        }\n        return this.finalize(node, expr);\n    };\n    Parser.prototype.parseAsyncArgument = function () {\n        var arg = this.parseAssignmentExpression();\n        this.context.firstCoverInitializedNameError = null;\n        return arg;\n    };\n    Parser.prototype.parseAsyncArguments = function () {\n        this.expect('(');\n        var args = [];\n        if (!this.match(')')) {\n            while (true) {\n                var expr = this.match('...') ? this.parseSpreadElement() :\n                    this.isolateCoverGrammar(this.parseAsyncArgument);\n                args.push(expr);\n                if (this.match(')')) {\n                    break;\n                }\n                this.expectCommaSeparator();\n                if (this.match(')')) {\n                    break;\n                }\n            }\n        }\n        this.expect(')');\n        return args;\n    };\n    Parser.prototype.matchImportCall = function () {\n        var match = this.matchKeyword('import');\n        if (match) {\n            var state = this.scanner.saveState();\n            this.scanner.scanComments();\n            var next = this.scanner.lex();\n            this.scanner.restoreState(state);\n            match = (next.type === 7 /* Token.Punctuator */) && (next.value === '(');\n        }\n        return match;\n    };\n    Parser.prototype.parseImportCall = function () {\n        var node = this.createNode();\n        this.expectKeyword('import');\n        this.expect(\"(\");\n        var source = this.parseAssignmentExpression();\n        var attributes = null;\n        if (this.match(\",\")) {\n            this.nextToken();\n            attributes = this.parseObjectInitializer();\n        }\n        if (!this.match(\")\") && this.config.tolerant) {\n            this.tolerateUnexpectedToken(this.nextToken());\n        }\n        else {\n            this.expect(\")\");\n            if (this.match(\";\")) {\n                this.nextToken();\n            }\n        }\n        return this.finalize(node, new Node.ImportExpression(source, attributes));\n    };\n    Parser.prototype.matchImportMeta = function () {\n        var match = this.matchKeyword('import');\n        if (match) {\n            var state = this.scanner.saveState();\n            this.scanner.scanComments();\n            var dot = this.scanner.lex();\n            if ((dot.type === 7 /* Token.Punctuator */) && (dot.value === '.')) {\n                this.scanner.scanComments();\n                var meta = this.scanner.lex();\n                match = (meta.type === 3 /* Token.Identifier */) && (meta.value === 'meta');\n                if (match) {\n                    if (meta.end - meta.start !== 'meta'.length) {\n                        this.tolerateUnexpectedToken(meta, messages_1.Messages.InvalidEscapedReservedWord);\n                    }\n                }\n            }\n            else {\n                match = false;\n            }\n            this.scanner.restoreState(state);\n        }\n        return match;\n    };\n    Parser.prototype.parseImportMeta = function () {\n        var node = this.createNode();\n        var id = this.parseIdentifierName(); // 'import', already ensured by matchImportMeta\n        this.expect('.');\n        var property = this.parseIdentifierName(); // 'meta', already ensured by matchImportMeta\n        this.context.isAssignmentTarget = false;\n        return this.finalize(node, new Node.MetaProperty(id, property));\n    };\n    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {\n        var startToken = this.lookahead;\n        var maybeAsync = this.matchContextualKeyword('async');\n        var previousAllowIn = this.context.allowIn;\n        this.context.allowIn = true;\n        var expr;\n        var isSuper = this.matchKeyword('super');\n        if (isSuper && this.context.inFunctionBody) {\n            expr = this.createNode();\n            this.nextToken();\n            expr = this.finalize(expr, new Node.Super());\n            if (!this.match('(') && !this.match('.') && !this.match('[')) {\n                this.throwUnexpectedToken(this.lookahead);\n            }\n        }\n        else {\n            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);\n        }\n        if (isSuper && this.match('(') && (!this.context.inClassConstructor || !this.context.allowSuper)) {\n            this.tolerateError(messages_1.Messages.UnexpectedSuper);\n        }\n        var hasOptional = false;\n        while (true) {\n            var optional = false;\n            if (this.match('?.')) {\n                optional = true;\n                hasOptional = true;\n                this.expect('?.');\n            }\n            if (this.match('(')) {\n                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);\n                this.context.isBindingElement = false;\n                this.context.isAssignmentTarget = false;\n                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();\n                if (expr.type === syntax_1.Syntax.ImportExpression && args.length !== 1) {\n                    this.tolerateError(messages_1.Messages.BadImportCallArity);\n                }\n                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args, optional));\n                if (asyncArrow && this.match('=>')) {\n                    for (var i = 0; i < args.length; ++i) {\n                        this.reinterpretExpressionAsPattern(args[i]);\n                    }\n                    expr = {\n                        type: ArrowParameterPlaceHolder,\n                        params: args,\n                        async: true\n                    };\n                }\n            }\n            else if (this.match('[')) {\n                this.context.isBindingElement = false;\n                this.context.isAssignmentTarget = !optional;\n                this.expect('[');\n                var property = this.isolateCoverGrammar(this.parseExpression);\n                this.expect(']');\n                expr = this.finalize(this.startNode(startToken), new Node.MemberExpression(true, expr, property, optional));\n            }\n            else if (this.lookahead.type === 10 /* Token.Template */ && this.lookahead.head) {\n                // Optional template literal is not included in the spec.\n                // https://github.com/tc39/proposal-optional-chaining/issues/54\n                if (optional) {\n                    this.throwUnexpectedToken(this.lookahead);\n                }\n                if (hasOptional) {\n                    this.throwError(messages_1.Messages.InvalidTaggedTemplateOnOptionalChain);\n                }\n                var quasi = this.parseTemplateLiteral({ isTagged: true });\n                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));\n            }\n            else if (this.match('.') || optional) {\n                this.context.isBindingElement = false;\n                this.context.isAssignmentTarget = !optional;\n                if (!optional) {\n                    this.expect('.');\n                }\n                var property = this.parseIdentifierName(true);\n                expr = this.finalize(this.startNode(startToken), new Node.MemberExpression(false, expr, property, optional));\n            }\n            else {\n                break;\n            }\n        }\n        this.context.allowIn = previousAllowIn;\n        if (hasOptional) {\n            return new Node.ChainExpression(expr);\n        }\n        return expr;\n    };\n    Parser.prototype.parseSuper = function () {\n        var node = this.createNode();\n        this.expectKeyword('super');\n        if (!this.match('[') && !this.match('.')) {\n            this.throwUnexpectedToken(this.lookahead);\n        }\n        return this.finalize(node, new Node.Super());\n    };\n    Parser.prototype.parseLeftHandSideExpression = function () {\n        (0, assert_1.assert)(this.context.allowIn, 'callee of new expression always allow in keyword.');\n        var node = this.startNode(this.lookahead);\n        var expr = (this.matchKeyword('super') && this.context.inFunctionBody)\n            ? this.parseSuper()\n            : this.inheritCoverGrammar(this.matchKeyword('new')\n                ? this.parseNewExpression\n                : this.parsePrimaryExpression);\n        var hasOptional = false;\n        while (true) {\n            var optional = false;\n            if (this.match('?.')) {\n                optional = true;\n                hasOptional = true;\n                this.expect('?.');\n            }\n            if (this.match('[')) {\n                this.context.isBindingElement = false;\n                this.context.isAssignmentTarget = !optional;\n                this.expect('[');\n                var property = this.isolateCoverGrammar(this.parseExpression);\n                this.expect(']');\n                expr = this.finalize(node, new Node.MemberExpression(true, expr, property, optional));\n            }\n            else if (this.lookahead.type === 10 /* Token.Template */ && this.lookahead.head) {\n                // Optional template literal is not included in the spec.\n                // https://github.com/tc39/proposal-optional-chaining/issues/54\n                if (optional) {\n                    this.throwUnexpectedToken(this.lookahead);\n                }\n                if (hasOptional) {\n                    this.throwError(messages_1.Messages.InvalidTaggedTemplateOnOptionalChain);\n                }\n                var quasi = this.parseTemplateLiteral({ isTagged: true });\n                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));\n            }\n            else if (this.match('.') || optional) {\n                this.context.isBindingElement = false;\n                this.context.isAssignmentTarget = !optional;\n                if (!optional) {\n                    this.expect('.');\n                }\n                var property = this.parseIdentifierName();\n                expr = this.finalize(node, new Node.MemberExpression(false, expr, property, optional));\n            }\n            else {\n                break;\n            }\n        }\n        if (hasOptional) {\n            return new Node.ChainExpression(expr);\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-update-expressions\n    Parser.prototype.parseUpdateExpression = function () {\n        var expr;\n        var startToken = this.lookahead;\n        if (this.match('++') || this.match('--')) {\n            var node = this.startNode(startToken);\n            var token = this.nextToken();\n            expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {\n                this.tolerateError(messages_1.Messages.StrictLHSPrefix);\n            }\n            if (!this.context.isAssignmentTarget) {\n                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\n            }\n            var prefix = true;\n            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n        }\n        else {\n            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Token.Punctuator */) {\n                if (this.match('++') || this.match('--')) {\n                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {\n                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);\n                    }\n                    if (!this.context.isAssignmentTarget) {\n                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\n                    }\n                    this.context.isAssignmentTarget = false;\n                    this.context.isBindingElement = false;\n                    var operator = this.nextToken().value;\n                    var prefix = false;\n                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));\n                }\n            }\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-unary-operators\n    Parser.prototype.parseAwaitExpression = function () {\n        var node = this.createNode();\n        this.nextToken();\n        var argument = this.parseUnaryExpression();\n        return this.finalize(node, new Node.AwaitExpression(argument));\n    };\n    Parser.prototype.parseUnaryExpression = function () {\n        var expr;\n        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||\n            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {\n            var node = this.startNode(this.lookahead);\n            var token = this.nextToken();\n            expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));\n            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {\n                this.tolerateError(messages_1.Messages.StrictDelete);\n            }\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n        }\n        else if (((this.context.isModule && !this.context.inFunctionBody) || this.context.isAsync) && this.matchContextualKeyword('await')) {\n            expr = this.parseAwaitExpression();\n        }\n        else {\n            expr = this.parseUpdateExpression();\n        }\n        return expr;\n    };\n    Parser.prototype.parseExponentiationExpression = function () {\n        var startToken = this.lookahead;\n        // -1 ** 2 is not accepted, but (-1) ** 2\n        // However, the AST for both cases is identical\n        // We distinguish the two cases by explicitly checking for a parenthesis.\n        var isLeftParenthesized = this.match('(');\n        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n        var exponentAllowed = expr.type !== syntax_1.Syntax.UnaryExpression || isLeftParenthesized;\n        if (exponentAllowed && this.match('**')) {\n            this.nextToken();\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n            var left = expr;\n            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-exp-operator\n    // https://tc39.github.io/ecma262/#sec-multiplicative-operators\n    // https://tc39.github.io/ecma262/#sec-additive-operators\n    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators\n    // https://tc39.github.io/ecma262/#sec-relational-operators\n    // https://tc39.github.io/ecma262/#sec-equality-operators\n    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators\n    // https://tc39.github.io/ecma262/#sec-binary-logical-operators\n    Parser.prototype.binaryPrecedence = function (token) {\n        var op = token.value;\n        var precedence;\n        if (token.type === 7 /* Token.Punctuator */) {\n            precedence = this.operatorPrecedence[op] || 0;\n        }\n        else if (token.type === 4 /* Token.Keyword */) {\n            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 12 : 0;\n        }\n        else {\n            precedence = 0;\n        }\n        return precedence;\n    };\n    Parser.prototype.parseBinaryExpression = function () {\n        var startToken = this.lookahead;\n        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);\n        var allowAndOr = true;\n        var allowNullishCoalescing = true;\n        var updateNullishCoalescingRestrictions = function (token) {\n            if (token.value === '&&' || token.value === '||') {\n                allowNullishCoalescing = false;\n            }\n            if (token.value === '??') {\n                allowAndOr = false;\n            }\n        };\n        var token = this.lookahead;\n        var prec = this.binaryPrecedence(token);\n        if (prec > 0) {\n            updateNullishCoalescingRestrictions(token);\n            this.nextToken();\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n            var markers = [startToken, this.lookahead];\n            var left = expr;\n            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n            var stack = [left, token.value, right];\n            var precedences = [prec];\n            while (true) {\n                prec = this.binaryPrecedence(this.lookahead);\n                if (prec <= 0) {\n                    break;\n                }\n                if ((!allowAndOr && (this.lookahead.value === '&&' || this.lookahead.value === '||')) ||\n                    (!allowNullishCoalescing && this.lookahead.value === '??')) {\n                    this.throwUnexpectedToken(this.lookahead);\n                }\n                updateNullishCoalescingRestrictions(this.lookahead);\n                // Reduce: make a binary expression from the three topmost entries.\n                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {\n                    right = stack.pop();\n                    var operator = stack.pop();\n                    precedences.pop();\n                    left = stack.pop();\n                    markers.pop();\n                    var marker = markers[markers.length - 1];\n                    var node = this.startNode(marker, marker.lineStart);\n                    var logical = (operator === '||' || operator === '&&' || operator === '??');\n                    stack.push(this.finalize(node, logical ? new Node.LogicalExpression(operator, left, right) : new Node.BinaryExpression(operator, left, right)));\n                }\n                // Shift.\n                stack.push(this.nextToken().value);\n                precedences.push(prec);\n                markers.push(this.lookahead);\n                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));\n            }\n            // Final reduce to clean-up the stack.\n            var i = stack.length - 1;\n            expr = stack[i];\n            var lastMarker = markers.pop();\n            while (i > 1) {\n                var marker = markers.pop();\n                var lastLineStart = lastMarker && lastMarker.lineStart;\n                var node = this.startNode(marker, lastLineStart);\n                var operator = stack[i - 1];\n                var logical = (operator === '||' || operator === '&&' || operator === '??');\n                expr = this.finalize(node, logical ? new Node.LogicalExpression(operator, stack[i - 2], expr) : new Node.BinaryExpression(operator, stack[i - 2], expr));\n                i -= 2;\n                lastMarker = marker;\n            }\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-conditional-operator\n    Parser.prototype.parseConditionalExpression = function () {\n        var startToken = this.lookahead;\n        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);\n        if (this.match('?')) {\n            this.nextToken();\n            var previousAllowIn = this.context.allowIn;\n            this.context.allowIn = true;\n            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);\n            this.context.allowIn = previousAllowIn;\n            this.expect(':');\n            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);\n            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-assignment-operators\n    Parser.prototype.checkPatternParam = function (options, param) {\n        switch (param.type) {\n            case syntax_1.Syntax.Identifier:\n                this.validateParam(options, param, param.name);\n                break;\n            case syntax_1.Syntax.RestElement:\n                this.checkPatternParam(options, param.argument);\n                break;\n            case syntax_1.Syntax.AssignmentPattern:\n                this.checkPatternParam(options, param.left);\n                break;\n            case syntax_1.Syntax.ArrayPattern:\n                for (var i = 0; i < param.elements.length; i++) {\n                    if (param.elements[i] !== null) {\n                        this.checkPatternParam(options, param.elements[i]);\n                    }\n                }\n                break;\n            case syntax_1.Syntax.ObjectPattern:\n                for (var i = 0; i < param.properties.length; i++) {\n                    var property = param.properties[i];\n                    this.checkPatternParam(options, (property.type === syntax_1.Syntax.RestElement) ? property : property.value);\n                }\n                break;\n            default:\n                break;\n        }\n        options.simple = options.simple && (param instanceof Node.Identifier);\n    };\n    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {\n        var params = [expr];\n        var options = {\n            simple: true,\n            paramSet: {}\n        };\n        var asyncArrow = false;\n        switch (expr.type) {\n            case syntax_1.Syntax.Identifier:\n                break;\n            case ArrowParameterPlaceHolder:\n                params = expr.params;\n                asyncArrow = expr.async;\n                break;\n            default:\n                return null;\n        }\n        for (var i = 0; i < params.length; ++i) {\n            var param = params[i];\n            if (param.type === syntax_1.Syntax.AssignmentPattern) {\n                if (param.right.type === syntax_1.Syntax.YieldExpression) {\n                    if (param.right.argument) {\n                        this.throwUnexpectedToken(this.lookahead);\n                    }\n                    param.right.type = syntax_1.Syntax.Identifier;\n                    param.right.name = 'yield';\n                    delete param.right.argument;\n                    delete param.right.delegate;\n                }\n            }\n            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {\n                this.throwUnexpectedToken(this.lookahead);\n            }\n            this.checkPatternParam(options, param);\n            params[i] = param;\n        }\n        if (this.context.strict || !this.context.allowYield) {\n            for (var i = 0; i < params.length; ++i) {\n                var param = params[i];\n                if (param.type === syntax_1.Syntax.YieldExpression) {\n                    this.throwUnexpectedToken(this.lookahead);\n                }\n            }\n        }\n        if (options.hasDuplicateParameterNames) {\n            var token = this.context.strict ? options.stricted : options.firstRestricted;\n            this.throwUnexpectedToken(token, messages_1.Messages.DuplicateParameter);\n        }\n        return {\n            simple: options.simple,\n            params: params,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    };\n    Parser.prototype.parseAssignmentExpression = function () {\n        var expr;\n        if (!this.context.allowYield && this.matchKeyword('yield')) {\n            expr = this.parseYieldExpression();\n        }\n        else {\n            var startToken = this.lookahead;\n            var token = startToken;\n            expr = this.parseConditionalExpression();\n            if (token.type === 3 /* Token.Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {\n                if (this.lookahead.type === 3 /* Token.Identifier */ || this.matchKeyword('yield')) {\n                    var arg = this.parsePrimaryExpression();\n                    this.reinterpretExpressionAsPattern(arg);\n                    expr = {\n                        type: ArrowParameterPlaceHolder,\n                        params: [arg],\n                        async: true\n                    };\n                }\n            }\n            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {\n                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions\n                this.context.isAssignmentTarget = false;\n                this.context.isBindingElement = false;\n                var isAsync = expr.async;\n                var list = this.reinterpretAsCoverFormalsList(expr);\n                if (list) {\n                    if (this.hasLineTerminator) {\n                        this.tolerateUnexpectedToken(this.lookahead);\n                    }\n                    this.context.firstCoverInitializedNameError = null;\n                    var previousStrict = this.context.strict;\n                    var previousAllowStrictDirective = this.context.allowStrictDirective;\n                    this.context.allowStrictDirective = list.simple;\n                    var previousAllowYield = this.context.allowYield;\n                    var previousIsAsync = this.context.isAsync;\n                    this.context.allowYield = true;\n                    this.context.isAsync = isAsync;\n                    var node = this.startNode(startToken);\n                    this.expect('=>');\n                    var body = void 0;\n                    if (this.match('{')) {\n                        var previousAllowIn = this.context.allowIn;\n                        this.context.allowIn = true;\n                        body = this.parseFunctionSourceElements();\n                        this.context.allowIn = previousAllowIn;\n                    }\n                    else {\n                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);\n                    }\n                    var expression = body.type !== syntax_1.Syntax.BlockStatement;\n                    if (this.context.strict && list.firstRestricted) {\n                        this.throwUnexpectedToken(list.firstRestricted, list.message);\n                    }\n                    if (this.context.strict && list.stricted) {\n                        this.tolerateUnexpectedToken(list.stricted, list.message);\n                    }\n                    expr = this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression, isAsync));\n                    this.context.strict = previousStrict;\n                    this.context.allowStrictDirective = previousAllowStrictDirective;\n                    this.context.allowYield = previousAllowYield;\n                    this.context.isAsync = previousIsAsync;\n                }\n            }\n            else {\n                if (this.matchAssign()) {\n                    if (!this.context.isAssignmentTarget) {\n                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\n                    }\n                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {\n                        var id = expr;\n                        if (this.scanner.isRestrictedWord(id.name)) {\n                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);\n                        }\n                        if (this.scanner.isStrictModeReservedWord(id.name)) {\n                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\n                        }\n                    }\n                    if (!this.match('=')) {\n                        this.context.isAssignmentTarget = false;\n                        this.context.isBindingElement = false;\n                    }\n                    else {\n                        this.reinterpretExpressionAsPattern(expr);\n                    }\n                    token = this.nextToken();\n                    var operator = token.value;\n                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);\n                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));\n                    this.context.firstCoverInitializedNameError = null;\n                }\n            }\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-comma-operator\n    Parser.prototype.parseExpression = function () {\n        var startToken = this.lookahead;\n        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);\n        if (this.match(',')) {\n            var expressions = [];\n            expressions.push(expr);\n            while (this.lookahead.type !== 2 /* Token.EOF */) {\n                if (!this.match(',')) {\n                    break;\n                }\n                this.nextToken();\n                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\n            }\n            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));\n        }\n        return expr;\n    };\n    // https://tc39.github.io/ecma262/#sec-block\n    Parser.prototype.parseStatementListItem = function () {\n        var statement;\n        this.context.isAssignmentTarget = true;\n        this.context.isBindingElement = true;\n        if (this.lookahead.type === 4 /* Token.Keyword */) {\n            switch (this.lookahead.value) {\n                case 'export':\n                    if (!this.context.isModule) {\n                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);\n                    }\n                    statement = this.parseExportDeclaration();\n                    break;\n                case 'import':\n                    if (this.matchImportCall()) {\n                        statement = this.parseExpressionStatement();\n                    }\n                    else if (this.matchImportMeta()) {\n                        statement = this.parseStatement();\n                    }\n                    else {\n                        if (!this.context.isModule) {\n                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);\n                        }\n                        statement = this.parseImportDeclaration();\n                    }\n                    break;\n                case 'const':\n                    statement = this.parseLexicalDeclaration({ inFor: false });\n                    break;\n                case 'function':\n                    statement = this.parseFunctionDeclaration();\n                    break;\n                case 'class':\n                    statement = this.parseClassDeclaration();\n                    break;\n                case 'let':\n                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();\n                    break;\n                default:\n                    statement = this.parseStatement();\n                    break;\n            }\n        }\n        else {\n            statement = this.parseStatement();\n        }\n        return statement;\n    };\n    Parser.prototype.parseBlock = function () {\n        var node = this.createNode();\n        this.expect('{');\n        var block = [];\n        while (true) {\n            if (this.match('}')) {\n                break;\n            }\n            block.push(this.parseStatementListItem());\n        }\n        this.expect('}');\n        return this.finalize(node, new Node.BlockStatement(block));\n    };\n    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations\n    Parser.prototype.parseLexicalBinding = function (kind, options) {\n        var node = this.createNode();\n        var params = [];\n        var id = this.parsePattern(params, kind);\n        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {\n            if (this.scanner.isRestrictedWord(id.name)) {\n                this.tolerateError(messages_1.Messages.StrictVarName);\n            }\n        }\n        var init = null;\n        if (kind === 'const') {\n            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {\n                if (this.match('=')) {\n                    this.nextToken();\n                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n                }\n                else {\n                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');\n                }\n            }\n        }\n        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {\n            this.expect('=');\n            init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n        }\n        return this.finalize(node, new Node.VariableDeclarator(id, init));\n    };\n    Parser.prototype.parseBindingList = function (kind, options) {\n        var list = [this.parseLexicalBinding(kind, options)];\n        while (this.match(',')) {\n            this.nextToken();\n            list.push(this.parseLexicalBinding(kind, options));\n        }\n        return list;\n    };\n    Parser.prototype.isLexicalDeclaration = function () {\n        var state = this.scanner.saveState();\n        this.scanner.scanComments();\n        var next = this.scanner.lex();\n        this.scanner.restoreState(state);\n        return (next.type === 3 /* Token.Identifier */) ||\n            (next.type === 7 /* Token.Punctuator */ && next.value === '[') ||\n            (next.type === 7 /* Token.Punctuator */ && next.value === '{') ||\n            (next.type === 4 /* Token.Keyword */ && next.value === 'let') ||\n            (next.type === 4 /* Token.Keyword */ && next.value === 'yield');\n    };\n    Parser.prototype.parseLexicalDeclaration = function (options) {\n        var node = this.createNode();\n        var kind = this.nextToken().value;\n        (0, assert_1.assert)(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n        var declarations = this.parseBindingList(kind, options);\n        this.consumeSemicolon();\n        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));\n    };\n    /**\n     * This function checks to see if a property is initialized in a Class\n     * e.g.\n     * publicProp = 123;\n     * @returns {Boolean}\n     */\n    Parser.prototype.isInitializedProperty = function () {\n        var state = this.scanner.saveState();\n        this.scanner.scanComments();\n        var next = this.scanner.lex();\n        this.scanner.restoreState(state);\n        return this.lookahead.type === 3 && next.value === '=';\n    };\n    /**\n     * This function checks to see if a property is declared in a Class\n     * e.g.\n     * publicProp;\n     * @returns {Boolean}\n     */\n    Parser.prototype.isDeclaredProperty = function () {\n        var state = this.scanner.saveState();\n        this.scanner.scanComments();\n        var next = this.scanner.lex();\n        this.scanner.restoreState(state);\n        return this.lookahead.type === 3 && next.value === ';'\n            || this.lookahead.type === 3 && next.lineNumber !== this.startMarker.line;\n    };\n    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns\n    Parser.prototype.parseBindingRestElement = function (params, kind) {\n        var node = this.createNode();\n        this.expect('...');\n        var arg = this.parsePattern(params, kind);\n        return this.finalize(node, new Node.RestElement(arg));\n    };\n    Parser.prototype.parseArrayPattern = function (params, kind) {\n        var node = this.createNode();\n        this.expect('[');\n        var elements = [];\n        while (!this.match(']')) {\n            if (this.match(',')) {\n                this.nextToken();\n                elements.push(null);\n            }\n            else {\n                if (this.match('...')) {\n                    elements.push(this.parseBindingRestElement(params, kind));\n                    break;\n                }\n                else {\n                    elements.push(this.parsePatternWithDefault(params, kind));\n                }\n                if (!this.match(']')) {\n                    this.expect(',');\n                }\n            }\n        }\n        this.expect(']');\n        return this.finalize(node, new Node.ArrayPattern(elements));\n    };\n    Parser.prototype.parsePropertyPattern = function (params, kind) {\n        var node = this.createNode();\n        var computed = false;\n        var shorthand = false;\n        var method = false;\n        var key;\n        var value;\n        if (this.lookahead.type === 3 /* Token.Identifier */) {\n            var keyToken = this.lookahead;\n            key = this.parseVariableIdentifier();\n            var init = this.finalize(node, new Node.Identifier(keyToken.value));\n            if (this.match('=')) {\n                params.push(keyToken);\n                shorthand = true;\n                this.nextToken();\n                var expr = this.parseAssignmentExpression();\n                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));\n            }\n            else if (!this.match(':')) {\n                params.push(keyToken);\n                shorthand = true;\n                value = init;\n            }\n            else {\n                this.expect(':');\n                value = this.parsePatternWithDefault(params, kind);\n            }\n        }\n        else {\n            computed = this.match('[');\n            key = this.parseObjectPropertyKey();\n            this.expect(':');\n            value = this.parsePatternWithDefault(params, kind);\n        }\n        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));\n    };\n    Parser.prototype.parseRestProperty = function (params) {\n        var node = this.createNode();\n        this.expect('...');\n        var arg = this.parsePattern(params);\n        if (this.match('=')) {\n            this.throwError(messages_1.Messages.DefaultRestProperty);\n        }\n        if (!this.match('}')) {\n            this.throwError(messages_1.Messages.PropertyAfterRestProperty);\n        }\n        return this.finalize(node, new Node.RestElement(arg));\n    };\n    Parser.prototype.parseObjectPattern = function (params, kind) {\n        var node = this.createNode();\n        var properties = [];\n        this.expect('{');\n        while (!this.match('}')) {\n            properties.push(this.match('...') ? this.parseRestProperty(params) : this.parsePropertyPattern(params, kind));\n            if (!this.match('}')) {\n                this.expect(',');\n            }\n        }\n        this.expect('}');\n        return this.finalize(node, new Node.ObjectPattern(properties));\n    };\n    Parser.prototype.parsePattern = function (params, kind) {\n        var pattern;\n        if (this.match('[')) {\n            pattern = this.parseArrayPattern(params, kind);\n        }\n        else if (this.match('{')) {\n            pattern = this.parseObjectPattern(params, kind);\n        }\n        else {\n            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {\n                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);\n            }\n            params.push(this.lookahead);\n            pattern = this.parseVariableIdentifier(kind);\n        }\n        return pattern;\n    };\n    Parser.prototype.parsePatternWithDefault = function (params, kind) {\n        var startToken = this.lookahead;\n        var pattern = this.parsePattern(params, kind);\n        if (this.match('=')) {\n            this.nextToken();\n            var previousAllowYield = this.context.allowYield;\n            this.context.allowYield = true;\n            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);\n            this.context.allowYield = previousAllowYield;\n            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));\n        }\n        return pattern;\n    };\n    // https://tc39.github.io/ecma262/#sec-variable-statement\n    Parser.prototype.parseVariableIdentifier = function (kind) {\n        var node = this.createNode();\n        var token = this.nextToken();\n        if (token.type === 4 /* Token.Keyword */ && token.value === 'yield') {\n            if (this.context.strict) {\n                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\n            }\n            else if (!this.context.allowYield) {\n                this.throwUnexpectedToken(token);\n            }\n        }\n        else if (token.type !== 3 /* Token.Identifier */) {\n            if (this.context.strict && token.type === 4 /* Token.Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {\n                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\n            }\n            else {\n                if (this.context.strict || token.value !== 'let' || kind !== 'var') {\n                    this.throwUnexpectedToken(token);\n                }\n            }\n        }\n        else if ((this.context.isModule || this.context.isAsync) && token.type === 3 /* Token.Identifier */ && token.value === 'await') {\n            this.tolerateUnexpectedToken(token);\n        }\n        return this.finalize(node, new Node.Identifier(token.value));\n    };\n    Parser.prototype.parseVariableDeclaration = function (options) {\n        var node = this.createNode();\n        var params = [];\n        var id = this.parsePattern(params, 'var');\n        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {\n            if (this.scanner.isRestrictedWord(id.name)) {\n                this.tolerateError(messages_1.Messages.StrictVarName);\n            }\n        }\n        var init = null;\n        if (this.match('=')) {\n            this.nextToken();\n            init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n        }\n        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {\n            this.expect('=');\n        }\n        return this.finalize(node, new Node.VariableDeclarator(id, init));\n    };\n    Parser.prototype.parseVariableDeclarationList = function (options) {\n        var opt = { inFor: options.inFor };\n        var list = [];\n        list.push(this.parseVariableDeclaration(opt));\n        while (this.match(',')) {\n            this.nextToken();\n            list.push(this.parseVariableDeclaration(opt));\n        }\n        return list;\n    };\n    Parser.prototype.parseVariableStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('var');\n        var declarations = this.parseVariableDeclarationList({ inFor: false });\n        this.consumeSemicolon();\n        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));\n    };\n    // https://tc39.github.io/ecma262/#sec-empty-statement\n    Parser.prototype.parseEmptyStatement = function () {\n        var node = this.createNode();\n        this.expect(';');\n        return this.finalize(node, new Node.EmptyStatement());\n    };\n    // https://tc39.github.io/ecma262/#sec-expression-statement\n    Parser.prototype.parseExpressionStatement = function () {\n        var node = this.createNode();\n        var expr = this.parseExpression();\n        this.consumeSemicolon();\n        return this.finalize(node, new Node.ExpressionStatement(expr));\n    };\n    // https://tc39.github.io/ecma262/#sec-if-statement\n    Parser.prototype.parseIfClause = function () {\n        if (this.context.strict && this.matchKeyword('function')) {\n            this.tolerateError(messages_1.Messages.StrictFunction);\n        }\n        return this.parseStatement();\n    };\n    Parser.prototype.parseIfStatement = function () {\n        var node = this.createNode();\n        var consequent;\n        var alternate = null;\n        this.expectKeyword('if');\n        this.expect('(');\n        var test = this.parseExpression();\n        if (!this.match(')') && this.config.tolerant) {\n            this.tolerateUnexpectedToken(this.nextToken());\n            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());\n        }\n        else {\n            this.expect(')');\n            consequent = this.parseIfClause();\n            if (this.matchKeyword('else')) {\n                this.nextToken();\n                alternate = this.parseIfClause();\n            }\n        }\n        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));\n    };\n    // https://tc39.github.io/ecma262/#sec-do-while-statement\n    Parser.prototype.parseDoWhileStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('do');\n        this.tolerateInvalidLoopStatement();\n        var previousInIteration = this.context.inIteration;\n        this.context.inIteration = true;\n        var body = this.parseStatement();\n        this.context.inIteration = previousInIteration;\n        this.expectKeyword('while');\n        this.expect('(');\n        var test = this.parseExpression();\n        if (!this.match(')') && this.config.tolerant) {\n            this.tolerateUnexpectedToken(this.nextToken());\n        }\n        else {\n            this.expect(')');\n            if (this.match(';')) {\n                this.nextToken();\n            }\n        }\n        return this.finalize(node, new Node.DoWhileStatement(body, test));\n    };\n    // https://tc39.github.io/ecma262/#sec-while-statement\n    Parser.prototype.parseWhileStatement = function () {\n        var node = this.createNode();\n        var body;\n        this.expectKeyword('while');\n        this.expect('(');\n        var test = this.parseExpression();\n        if (!this.match(')') && this.config.tolerant) {\n            this.tolerateUnexpectedToken(this.nextToken());\n            body = this.finalize(this.createNode(), new Node.EmptyStatement());\n        }\n        else {\n            this.expect(')');\n            var previousInIteration = this.context.inIteration;\n            this.context.inIteration = true;\n            body = this.parseStatement();\n            this.context.inIteration = previousInIteration;\n        }\n        return this.finalize(node, new Node.WhileStatement(test, body));\n    };\n    // https://tc39.github.io/ecma262/#sec-for-statement\n    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\n    Parser.prototype.parseForStatement = function () {\n        var init = null;\n        var test = null;\n        var update = null;\n        var forIn = true;\n        var left, right;\n        var _await = false;\n        var node = this.createNode();\n        this.expectKeyword('for');\n        if (this.matchContextualKeyword('await')) {\n            if (!this.context.isAsync) {\n                this.tolerateUnexpectedToken(this.lookahead);\n            }\n            _await = true;\n            this.nextToken();\n        }\n        this.expect('(');\n        if (this.match(';')) {\n            this.nextToken();\n        }\n        else {\n            if (this.matchKeyword('var')) {\n                init = this.createNode();\n                this.nextToken();\n                var previousAllowIn = this.context.allowIn;\n                this.context.allowIn = false;\n                var declarations = this.parseVariableDeclarationList({ inFor: true });\n                this.context.allowIn = previousAllowIn;\n                if (!_await && declarations.length === 1 && this.matchKeyword('in')) {\n                    var decl = declarations[0];\n                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {\n                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');\n                    }\n                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));\n                    this.nextToken();\n                    left = init;\n                    right = this.parseExpression();\n                    init = null;\n                }\n                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {\n                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));\n                    this.nextToken();\n                    left = init;\n                    right = this.parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                }\n                else {\n                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));\n                    this.expect(';');\n                }\n            }\n            else if (this.matchKeyword('const') || this.matchKeyword('let')) {\n                init = this.createNode();\n                var kind = this.nextToken().value;\n                if (!this.context.strict && this.lookahead.value === 'in') {\n                    init = this.finalize(init, new Node.Identifier(kind));\n                    this.nextToken();\n                    left = init;\n                    right = this.parseExpression();\n                    init = null;\n                }\n                else {\n                    var previousAllowIn = this.context.allowIn;\n                    this.context.allowIn = false;\n                    var declarations = this.parseBindingList(kind, { inFor: true });\n                    this.context.allowIn = previousAllowIn;\n                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {\n                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\n                        this.nextToken();\n                        left = init;\n                        right = this.parseExpression();\n                        init = null;\n                    }\n                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {\n                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\n                        this.nextToken();\n                        left = init;\n                        right = this.parseAssignmentExpression();\n                        init = null;\n                        forIn = false;\n                    }\n                    else {\n                        this.consumeSemicolon();\n                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\n                    }\n                }\n            }\n            else {\n                var initStartToken = this.lookahead;\n                var previousIsBindingElement = this.context.isBindingElement;\n                var previousIsAssignmentTarget = this.context.isAssignmentTarget;\n                var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n                var previousAllowIn = this.context.allowIn;\n                this.context.allowIn = false;\n                init = this.inheritCoverGrammar(this.parseAssignmentExpression);\n                this.context.allowIn = previousAllowIn;\n                if (this.matchKeyword('in')) {\n                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {\n                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);\n                    }\n                    this.nextToken();\n                    this.reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = this.parseExpression();\n                    init = null;\n                }\n                else if (this.matchContextualKeyword('of')) {\n                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {\n                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);\n                    }\n                    this.nextToken();\n                    this.reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = this.parseAssignmentExpression();\n                    init = null;\n                    forIn = false;\n                }\n                else {\n                    // The `init` node was not parsed isolated, but we would have wanted it to.\n                    this.context.isBindingElement = previousIsBindingElement;\n                    this.context.isAssignmentTarget = previousIsAssignmentTarget;\n                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;\n                    if (this.match(',')) {\n                        var initSeq = [init];\n                        while (this.match(',')) {\n                            this.nextToken();\n                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\n                        }\n                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));\n                    }\n                    this.expect(';');\n                }\n            }\n        }\n        if (typeof left === 'undefined') {\n            if (!this.match(';')) {\n                test = this.isolateCoverGrammar(this.parseExpression);\n            }\n            this.expect(';');\n            if (!this.match(')')) {\n                update = this.isolateCoverGrammar(this.parseExpression);\n            }\n        }\n        var body;\n        if (!this.match(')') && this.config.tolerant) {\n            this.tolerateUnexpectedToken(this.nextToken());\n            body = this.finalize(this.createNode(), new Node.EmptyStatement());\n        }\n        else {\n            this.expect(')');\n            this.tolerateInvalidLoopStatement();\n            var previousInIteration = this.context.inIteration;\n            this.context.inIteration = true;\n            body = this.isolateCoverGrammar(this.parseStatement);\n            this.context.inIteration = previousInIteration;\n        }\n        return (typeof left === 'undefined') ?\n            this.finalize(node, new Node.ForStatement(init, test, update, body)) :\n            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :\n                this.finalize(node, new Node.ForOfStatement(left, right, body, _await));\n    };\n    // https://tc39.github.io/ecma262/#sec-continue-statement\n    Parser.prototype.parseContinueStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('continue');\n        var label = null;\n        if (this.lookahead.type === 3 /* Token.Identifier */ && !this.hasLineTerminator) {\n            var id = this.parseVariableIdentifier();\n            label = id;\n            var key = '$' + id.name;\n            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n                this.throwError(messages_1.Messages.UnknownLabel, id.name);\n            }\n        }\n        this.consumeSemicolon();\n        if (label === null && !this.context.inIteration) {\n            this.throwError(messages_1.Messages.IllegalContinue);\n        }\n        return this.finalize(node, new Node.ContinueStatement(label));\n    };\n    // https://tc39.github.io/ecma262/#sec-break-statement\n    Parser.prototype.parseBreakStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('break');\n        var label = null;\n        if (this.lookahead.type === 3 /* Token.Identifier */ && !this.hasLineTerminator) {\n            var id = this.parseVariableIdentifier();\n            var key = '$' + id.name;\n            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n                this.throwError(messages_1.Messages.UnknownLabel, id.name);\n            }\n            label = id;\n        }\n        this.consumeSemicolon();\n        if (label === null && !this.context.inIteration && !this.context.inSwitch) {\n            this.throwError(messages_1.Messages.IllegalBreak);\n        }\n        return this.finalize(node, new Node.BreakStatement(label));\n    };\n    // https://tc39.github.io/ecma262/#sec-return-statement\n    Parser.prototype.parseReturnStatement = function () {\n        if (!this.context.inFunctionBody) {\n            this.tolerateError(messages_1.Messages.IllegalReturn);\n        }\n        var node = this.createNode();\n        this.expectKeyword('return');\n        var hasArgument = (!this.match(';') && !this.match('}') &&\n            !this.hasLineTerminator && this.lookahead.type !== 2 /* Token.EOF */) ||\n            this.lookahead.type === 8 /* Token.StringLiteral */ ||\n            this.lookahead.type === 10 /* Token.Template */;\n        var argument = hasArgument ? this.parseExpression() : null;\n        this.consumeSemicolon();\n        return this.finalize(node, new Node.ReturnStatement(argument));\n    };\n    // https://tc39.github.io/ecma262/#sec-with-statement\n    Parser.prototype.parseWithStatement = function () {\n        if (this.context.strict) {\n            this.tolerateError(messages_1.Messages.StrictModeWith);\n        }\n        var node = this.createNode();\n        var body;\n        this.expectKeyword('with');\n        this.expect('(');\n        var object = this.parseExpression();\n        if (!this.match(')') && this.config.tolerant) {\n            this.tolerateUnexpectedToken(this.nextToken());\n            body = this.finalize(this.createNode(), new Node.EmptyStatement());\n        }\n        else {\n            this.expect(')');\n            body = this.parseStatement();\n        }\n        return this.finalize(node, new Node.WithStatement(object, body));\n    };\n    // https://tc39.github.io/ecma262/#sec-switch-statement\n    Parser.prototype.parseSwitchCase = function () {\n        var node = this.createNode();\n        var test;\n        if (this.matchKeyword('default')) {\n            this.nextToken();\n            test = null;\n        }\n        else {\n            this.expectKeyword('case');\n            test = this.parseExpression();\n        }\n        this.expect(':');\n        var consequent = [];\n        while (true) {\n            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {\n                break;\n            }\n            consequent.push(this.parseStatementListItem());\n        }\n        return this.finalize(node, new Node.SwitchCase(test, consequent));\n    };\n    Parser.prototype.parseSwitchStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('switch');\n        this.expect('(');\n        var discriminant = this.parseExpression();\n        this.expect(')');\n        var previousInSwitch = this.context.inSwitch;\n        this.context.inSwitch = true;\n        var cases = [];\n        var defaultFound = false;\n        this.expect('{');\n        while (true) {\n            if (this.match('}')) {\n                break;\n            }\n            var clause = this.parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n        this.expect('}');\n        this.context.inSwitch = previousInSwitch;\n        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));\n    };\n    // https://tc39.github.io/ecma262/#sec-labelled-statements\n    Parser.prototype.parseLabelledStatement = function () {\n        var node = this.createNode();\n        var expr = this.parseExpression();\n        var statement;\n        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {\n            this.nextToken();\n            var id = expr;\n            var key = '$' + id.name;\n            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);\n            }\n            this.context.labelSet[key] = true;\n            var body = void 0;\n            if (this.matchKeyword('class')) {\n                this.tolerateUnexpectedToken(this.lookahead);\n                body = this.parseClassDeclaration();\n            }\n            else if (this.matchKeyword('function')) {\n                var token = this.lookahead;\n                var declaration = this.parseFunctionDeclaration();\n                if (this.context.strict) {\n                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);\n                }\n                else if (declaration.generator) {\n                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);\n                }\n                body = declaration;\n            }\n            else {\n                body = this.parseStatement();\n            }\n            delete this.context.labelSet[key];\n            statement = new Node.LabeledStatement(id, body);\n        }\n        else {\n            this.consumeSemicolon();\n            statement = new Node.ExpressionStatement(expr);\n        }\n        return this.finalize(node, statement);\n    };\n    // https://tc39.github.io/ecma262/#sec-throw-statement\n    Parser.prototype.parseThrowStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('throw');\n        if (this.hasLineTerminator) {\n            this.throwError(messages_1.Messages.NewlineAfterThrow);\n        }\n        var argument = this.parseExpression();\n        this.consumeSemicolon();\n        return this.finalize(node, new Node.ThrowStatement(argument));\n    };\n    // https://tc39.github.io/ecma262/#sec-try-statement\n    Parser.prototype.parseCatchClause = function () {\n        var node = this.createNode();\n        this.expectKeyword('catch');\n        var param = null;\n        if (this.match('(')) {\n            this.expect('(');\n            if (this.match(')')) {\n                this.throwUnexpectedToken(this.lookahead);\n            }\n            var params = [];\n            param = this.parsePattern(params);\n            var paramMap = {};\n            for (var i = 0; i < params.length; i++) {\n                var key = '$' + params[i].value;\n                if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n                    this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);\n                }\n                paramMap[key] = true;\n            }\n            if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {\n                if (this.scanner.isRestrictedWord(param.name)) {\n                    this.tolerateError(messages_1.Messages.StrictCatchVariable);\n                }\n            }\n            this.expect(')');\n        }\n        var body = this.parseBlock();\n        return this.finalize(node, new Node.CatchClause(param, body));\n    };\n    Parser.prototype.parseFinallyClause = function () {\n        this.expectKeyword('finally');\n        return this.parseBlock();\n    };\n    Parser.prototype.parseTryStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('try');\n        var block = this.parseBlock();\n        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;\n        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;\n        if (!handler && !finalizer) {\n            this.throwError(messages_1.Messages.NoCatchOrFinally);\n        }\n        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));\n    };\n    // https://tc39.github.io/ecma262/#sec-debugger-statement\n    Parser.prototype.parseDebuggerStatement = function () {\n        var node = this.createNode();\n        this.expectKeyword('debugger');\n        this.consumeSemicolon();\n        return this.finalize(node, new Node.DebuggerStatement());\n    };\n    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations\n    Parser.prototype.parseStatement = function () {\n        var statement;\n        switch (this.lookahead.type) {\n            case 1 /* Token.BooleanLiteral */:\n            case 5 /* Token.NullLiteral */:\n            case 6 /* Token.NumericLiteral */:\n            case 8 /* Token.StringLiteral */:\n            case 10 /* Token.Template */:\n            case 9 /* Token.RegularExpression */:\n                statement = this.parseExpressionStatement();\n                break;\n            case 7 /* Token.Punctuator */:\n                var value = this.lookahead.value;\n                if (value === '{') {\n                    statement = this.parseBlock();\n                }\n                else if (value === '(') {\n                    statement = this.parseExpressionStatement();\n                }\n                else if (value === ';') {\n                    statement = this.parseEmptyStatement();\n                }\n                else {\n                    statement = this.parseExpressionStatement();\n                }\n                break;\n            case 3 /* Token.Identifier */:\n                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();\n                break;\n            case 4 /* Token.Keyword */:\n                switch (this.lookahead.value) {\n                    case 'break':\n                        statement = this.parseBreakStatement();\n                        break;\n                    case 'continue':\n                        statement = this.parseContinueStatement();\n                        break;\n                    case 'debugger':\n                        statement = this.parseDebuggerStatement();\n                        break;\n                    case 'do':\n                        statement = this.parseDoWhileStatement();\n                        break;\n                    case 'for':\n                        statement = this.parseForStatement();\n                        break;\n                    case 'function':\n                        statement = this.parseFunctionDeclaration();\n                        break;\n                    case 'if':\n                        statement = this.parseIfStatement();\n                        break;\n                    case 'return':\n                        statement = this.parseReturnStatement();\n                        break;\n                    case 'switch':\n                        statement = this.parseSwitchStatement();\n                        break;\n                    case 'throw':\n                        statement = this.parseThrowStatement();\n                        break;\n                    case 'try':\n                        statement = this.parseTryStatement();\n                        break;\n                    case 'var':\n                        statement = this.parseVariableStatement();\n                        break;\n                    case 'while':\n                        statement = this.parseWhileStatement();\n                        break;\n                    case 'with':\n                        statement = this.parseWithStatement();\n                        break;\n                    default:\n                        statement = this.parseExpressionStatement();\n                        break;\n                }\n                break;\n            default:\n                statement = this.throwUnexpectedToken(this.lookahead);\n        }\n        return statement;\n    };\n    // https://tc39.github.io/ecma262/#sec-function-definitions\n    Parser.prototype.parseFunctionSourceElements = function () {\n        var node = this.createNode();\n        this.expect('{');\n        var body = this.parseDirectivePrologues();\n        var previousLabelSet = this.context.labelSet;\n        var previousInIteration = this.context.inIteration;\n        var previousInSwitch = this.context.inSwitch;\n        var previousInFunctionBody = this.context.inFunctionBody;\n        this.context.labelSet = {};\n        this.context.inIteration = false;\n        this.context.inSwitch = false;\n        this.context.inFunctionBody = true;\n        while (this.lookahead.type !== 2 /* Token.EOF */) {\n            if (this.match('}')) {\n                break;\n            }\n            body.push(this.parseStatementListItem());\n        }\n        this.expect('}');\n        this.context.labelSet = previousLabelSet;\n        this.context.inIteration = previousInIteration;\n        this.context.inSwitch = previousInSwitch;\n        this.context.inFunctionBody = previousInFunctionBody;\n        return this.finalize(node, new Node.BlockStatement(body));\n    };\n    Parser.prototype.validateParam = function (options, param, name) {\n        var key = '$' + name;\n        if (this.context.strict) {\n            if (this.scanner.isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = messages_1.Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.hasDuplicateParameterNames = true;\n            }\n        }\n        else if (!options.firstRestricted) {\n            if (this.scanner.isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = messages_1.Messages.StrictParamName;\n            }\n            else if (this.scanner.isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = messages_1.Messages.StrictReservedWord;\n            }\n            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.hasDuplicateParameterNames = true;\n            }\n        }\n        /* istanbul ignore next */\n        if (typeof Object.defineProperty === 'function') {\n            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });\n        }\n        else {\n            options.paramSet[key] = true;\n        }\n    };\n    Parser.prototype.parseRestElement = function (params) {\n        var node = this.createNode();\n        this.expect('...');\n        var arg = this.parsePattern(params);\n        if (this.match('=')) {\n            this.throwError(messages_1.Messages.DefaultRestParameter);\n        }\n        if (!this.match(')')) {\n            this.throwError(messages_1.Messages.ParameterAfterRestParameter);\n        }\n        return this.finalize(node, new Node.RestElement(arg));\n    };\n    Parser.prototype.parseFormalParameter = function (options) {\n        var params = [];\n        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);\n        for (var i = 0; i < params.length; i++) {\n            this.validateParam(options, params[i], params[i].value);\n        }\n        options.simple = options.simple && (param instanceof Node.Identifier);\n        options.params.push(param);\n    };\n    Parser.prototype.parseFormalParameters = function (firstRestricted) {\n        var options = {\n            simple: true,\n            hasDuplicateParameterNames: false,\n            params: [],\n            firstRestricted: firstRestricted\n        };\n        this.expect('(');\n        if (!this.match(')')) {\n            options.paramSet = {};\n            while (this.lookahead.type !== 2 /* Token.EOF */) {\n                this.parseFormalParameter(options);\n                if (this.match(')')) {\n                    break;\n                }\n                this.expect(',');\n                if (this.match(')')) {\n                    break;\n                }\n            }\n        }\n        this.expect(')');\n        if (options.hasDuplicateParameterNames) {\n            if (this.context.strict || this.context.isAsync || !options.simple) {\n                this.throwError(messages_1.Messages.DuplicateParameter);\n            }\n        }\n        return {\n            simple: options.simple,\n            params: options.params,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    };\n    Parser.prototype.matchAsyncFunction = function () {\n        var match = this.matchContextualKeyword('async');\n        if (match) {\n            var state = this.scanner.saveState();\n            this.scanner.scanComments();\n            var next = this.scanner.lex();\n            this.scanner.restoreState(state);\n            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Token.Keyword */) && (next.value === 'function');\n        }\n        return match;\n    };\n    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {\n        var node = this.createNode();\n        var isAsync = this.matchContextualKeyword('async');\n        if (isAsync) {\n            if (this.context.inIteration) {\n                this.tolerateError(messages_1.Messages.AsyncFunctionInSingleStatementContext);\n            }\n            this.nextToken();\n        }\n        this.expectKeyword('function');\n        var isGenerator = this.match('*');\n        if (isGenerator) {\n            this.nextToken();\n        }\n        var message;\n        var id = null;\n        var firstRestricted = null;\n        if (!identifierIsOptional || !this.match('(')) {\n            var token = this.lookahead;\n            id = this.parseVariableIdentifier();\n            if (this.context.strict) {\n                if (this.scanner.isRestrictedWord(token.value)) {\n                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);\n                }\n            }\n            else {\n                if (this.scanner.isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = messages_1.Messages.StrictFunctionName;\n                }\n                else if (this.scanner.isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = messages_1.Messages.StrictReservedWord;\n                }\n            }\n        }\n        var previousIsAsync = this.context.isAsync;\n        var previousAllowYield = this.context.allowYield;\n        this.context.isAsync = isAsync;\n        this.context.allowYield = !isGenerator;\n        var formalParameters = this.parseFormalParameters(firstRestricted);\n        var params = formalParameters.params;\n        var stricted = formalParameters.stricted;\n        firstRestricted = formalParameters.firstRestricted;\n        if (formalParameters.message) {\n            message = formalParameters.message;\n        }\n        var previousStrict = this.context.strict;\n        var previousAllowStrictDirective = this.context.allowStrictDirective;\n        this.context.allowStrictDirective = formalParameters.simple;\n        var body = this.parseFunctionSourceElements();\n        if (this.context.strict && firstRestricted) {\n            this.throwUnexpectedToken(firstRestricted, message);\n        }\n        if (this.context.strict && stricted) {\n            this.tolerateUnexpectedToken(stricted, message);\n        }\n        this.context.strict = previousStrict;\n        this.context.allowStrictDirective = previousAllowStrictDirective;\n        this.context.isAsync = previousIsAsync;\n        this.context.allowYield = previousAllowYield;\n        return isAsync\n            ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body, isGenerator))\n            : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));\n    };\n    Parser.prototype.parseFunctionExpression = function () {\n        var node = this.createNode();\n        var isAsync = this.matchContextualKeyword('async');\n        if (isAsync) {\n            this.nextToken();\n        }\n        this.expectKeyword('function');\n        var isGenerator = this.match('*');\n        if (isGenerator) {\n            this.nextToken();\n        }\n        var message;\n        var id = null;\n        var firstRestricted;\n        var previousIsAsync = this.context.isAsync;\n        var previousAllowYield = this.context.allowYield;\n        this.context.isAsync = isAsync;\n        this.context.allowYield = !isGenerator;\n        if (!this.match('(')) {\n            var token = this.lookahead;\n            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();\n            if (this.context.strict) {\n                if (this.scanner.isRestrictedWord(token.value)) {\n                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);\n                }\n            }\n            else {\n                if (this.scanner.isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = messages_1.Messages.StrictFunctionName;\n                }\n                else if (this.scanner.isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = messages_1.Messages.StrictReservedWord;\n                }\n            }\n        }\n        var formalParameters = this.parseFormalParameters(firstRestricted);\n        var params = formalParameters.params;\n        var stricted = formalParameters.stricted;\n        firstRestricted = formalParameters.firstRestricted;\n        if (formalParameters.message) {\n            message = formalParameters.message;\n        }\n        var previousStrict = this.context.strict;\n        var previousAllowStrictDirective = this.context.allowStrictDirective;\n        this.context.allowStrictDirective = formalParameters.simple;\n        var body = this.parseFunctionSourceElements();\n        if (this.context.strict && firstRestricted) {\n            this.throwUnexpectedToken(firstRestricted, message);\n        }\n        if (this.context.strict && stricted) {\n            this.tolerateUnexpectedToken(stricted, message);\n        }\n        this.context.strict = previousStrict;\n        this.context.allowStrictDirective = previousAllowStrictDirective;\n        this.context.isAsync = previousIsAsync;\n        this.context.allowYield = previousAllowYield;\n        return this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator, isAsync));\n    };\n    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive\n    Parser.prototype.parseDirective = function () {\n        var token = this.lookahead;\n        var node = this.createNode();\n        var expr = this.parseExpression();\n        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;\n        this.consumeSemicolon();\n        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));\n    };\n    Parser.prototype.parseDirectivePrologues = function () {\n        var firstRestricted = null;\n        var body = [];\n        while (true) {\n            var token = this.lookahead;\n            if (token.type !== 8 /* Token.StringLiteral */) {\n                break;\n            }\n            var statement = this.parseDirective();\n            body.push(statement);\n            var directive = statement.directive;\n            if (typeof directive !== 'string') {\n                break;\n            }\n            if (directive === 'use strict') {\n                this.context.strict = true;\n                if (firstRestricted) {\n                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);\n                }\n                if (!this.context.allowStrictDirective) {\n                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);\n                }\n            }\n            else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n        return body;\n    };\n    // https://tc39.github.io/ecma262/#sec-method-definitions\n    Parser.prototype.qualifiedPropertyName = function (token) {\n        switch (token.type) {\n            case 3 /* Token.Identifier */:\n            case 8 /* Token.StringLiteral */:\n            case 1 /* Token.BooleanLiteral */:\n            case 5 /* Token.NullLiteral */:\n            case 6 /* Token.NumericLiteral */:\n            case 4 /* Token.Keyword */:\n                return true;\n            case 7 /* Token.Punctuator */:\n                return token.value === '[' || token.value === '#';\n            default:\n                break;\n        }\n        return false;\n    };\n    Parser.prototype.parseGetterMethod = function () {\n        var node = this.createNode();\n        var isGenerator = false;\n        var previousAllowYield = this.context.allowYield;\n        this.context.allowYield = !isGenerator;\n        var formalParameters = this.parseFormalParameters();\n        if (formalParameters.params.length > 0) {\n            this.tolerateError(messages_1.Messages.BadGetterArity);\n        }\n        var method = this.parsePropertyMethod(formalParameters);\n        this.context.allowYield = previousAllowYield;\n        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator, false));\n    };\n    Parser.prototype.parseSetterMethod = function () {\n        var node = this.createNode();\n        var isGenerator = false;\n        var previousAllowYield = this.context.allowYield;\n        this.context.allowYield = !isGenerator;\n        var formalParameters = this.parseFormalParameters();\n        if (formalParameters.params.length !== 1) {\n            this.tolerateError(messages_1.Messages.BadSetterArity);\n        }\n        else if (formalParameters.params[0] instanceof Node.RestElement) {\n            this.tolerateError(messages_1.Messages.BadSetterRestParameter);\n        }\n        var method = this.parsePropertyMethod(formalParameters);\n        this.context.allowYield = previousAllowYield;\n        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator, false));\n    };\n    Parser.prototype.parseGeneratorMethod = function (isAsync) {\n        var node = this.createNode();\n        var isGenerator = true;\n        var previousAllowYield = this.context.allowYield;\n        this.context.allowYield = true;\n        var params = this.parseFormalParameters();\n        this.context.allowYield = false;\n        var method = this.parsePropertyMethod(params);\n        this.context.allowYield = previousAllowYield;\n        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator, isAsync));\n    };\n    // https://tc39.github.io/ecma262/#sec-generator-function-definitions\n    Parser.prototype.isStartOfExpression = function () {\n        var start = true;\n        var value = this.lookahead.value;\n        switch (this.lookahead.type) {\n            case 7 /* Token.Punctuator */:\n                start = (value === '[') || (value === '(') || (value === '{') ||\n                    (value === '+') || (value === '-') ||\n                    (value === '!') || (value === '~') ||\n                    (value === '++') || (value === '--') ||\n                    (value === '/') || (value === '/='); // regular expression literal\n                break;\n            case 4 /* Token.Keyword */:\n                start = (value === 'class') || (value === 'delete') ||\n                    (value === 'function') || (value === 'let') || (value === 'new') ||\n                    (value === 'super') || (value === 'this') || (value === 'typeof') ||\n                    (value === 'void') || (value === 'yield');\n                break;\n            default:\n                break;\n        }\n        return start;\n    };\n    Parser.prototype.parseYieldExpression = function () {\n        var node = this.createNode();\n        this.expectKeyword('yield');\n        var argument = null;\n        var delegate = false;\n        if (!this.hasLineTerminator) {\n            var previousAllowYield = this.context.allowYield;\n            this.context.allowYield = false;\n            delegate = this.match('*');\n            if (delegate) {\n                this.nextToken();\n                argument = this.parseAssignmentExpression();\n            }\n            else if (this.isStartOfExpression()) {\n                argument = this.parseAssignmentExpression();\n            }\n            this.context.allowYield = previousAllowYield;\n        }\n        return this.finalize(node, new Node.YieldExpression(argument, delegate));\n    };\n    // https://tc39.github.io/ecma262/#sec-class-definitions\n    Parser.prototype.parseStaticBlock = function () {\n        var node = this.createNode();\n        this.expect('{');\n        var block = [];\n        while (true) {\n            if (this.match('}')) {\n                break;\n            }\n            block.push(this.parseStatementListItem());\n        }\n        this.expect('}');\n        return this.finalize(node, new Node.StaticBlock(block));\n    };\n    Parser.prototype.parseDecorator = function () {\n        var node = this.createNode();\n        this.expect(\"@\");\n        var previousStrict = this.context.strict;\n        var previousAllowYield = this.context.allowYield;\n        var previousIsAsync = this.context.isAsync;\n        this.context.strict = false;\n        this.context.allowYield = true;\n        this.context.isAsync = false;\n        var expression = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n        this.context.strict = previousStrict;\n        this.context.allowYield = previousAllowYield;\n        this.context.isAsync = previousIsAsync;\n        if (this.match(\";\")) {\n            this.throwError(messages_1.Messages.NoSemicolonAfterDecorator);\n        }\n        return this.finalize(node, new Node.Decorator(expression));\n    };\n    Parser.prototype.parseDecorators = function () {\n        var decorators = null;\n        while (this.match(\"@\")) {\n            if (decorators == null)\n                decorators = [];\n            decorators.push(this.parseDecorator());\n        }\n        return decorators;\n    };\n    Parser.prototype.parseClassElement = function (hasConstructor) {\n        var token = this.lookahead;\n        var node = this.createNode();\n        var previousInConstructor = this.context.inConstructor;\n        var kind = '';\n        var key = null;\n        var value = null;\n        var computed = false;\n        var method = false;\n        var isStatic = false;\n        var isAsync = false;\n        var isGenerator = false;\n        var isPrivate = false;\n        var decorators = this.parseDecorators();\n        if (decorators) {\n            token = this.lookahead;\n        }\n        if (this.match('*')) {\n            this.nextToken();\n        }\n        else {\n            computed = this.match('[');\n            if (this.match('#')) {\n                isPrivate = true;\n                this.nextToken();\n                token = this.lookahead;\n            }\n            key = this.parseObjectPropertyKey(isPrivate);\n            var id = key;\n            this.context.inConstructor = token.type === 3 /* Token.Identifier */ && token.value === 'constructor';\n            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {\n                token = this.lookahead;\n                isStatic = true;\n                computed = this.match('[');\n                if (this.match('*')) {\n                    this.nextToken();\n                    if (this.match('#')) {\n                        isPrivate = true;\n                        this.nextToken();\n                        token = this.lookahead;\n                    }\n                }\n                else {\n                    if (this.match('#')) {\n                        isPrivate = true;\n                        this.nextToken();\n                        token = this.lookahead;\n                    }\n                    key = this.parseObjectPropertyKey(isPrivate);\n                }\n            }\n            if (id.name === 'static' && this.match('{')) {\n                return this.parseStaticBlock();\n            }\n            if ((token.type === 3 /* Token.Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {\n                var punctuator = this.lookahead.value;\n                if (punctuator !== ':' && punctuator !== '(') {\n                    isAsync = true;\n                    isGenerator = this.match(\"*\");\n                    if (isGenerator) {\n                        this.nextToken();\n                    }\n                    token = this.lookahead;\n                    computed = this.match('[');\n                    if (this.match('*')) {\n                        this.nextToken();\n                        if (this.match('#')) {\n                            isPrivate = true;\n                            this.nextToken();\n                        }\n                    }\n                    else {\n                        if (this.match('#')) {\n                            isPrivate = true;\n                            this.nextToken();\n                            token = this.lookahead;\n                        }\n                        key = this.parseObjectPropertyKey(isPrivate);\n                    }\n                    if (token.type === 3 /* Token.Identifier */ && token.value === 'constructor' && !isStatic) {\n                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);\n                    }\n                }\n            }\n        }\n        if (token.type === 3 /* Token.Identifier */ && token.value === 'constructor' && isPrivate) {\n            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsPrivate);\n        }\n        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\n        if (token.type === 3 /* Token.Identifier */ || token.type === 8 /* Token.StringLiteral */) {\n            if (token.value === 'get' && lookaheadPropertyKey) {\n                kind = 'get';\n                if (this.match('#')) {\n                    isPrivate = true;\n                    this.nextToken();\n                    token = this.lookahead;\n                }\n                computed = this.match('[');\n                key = this.parseObjectPropertyKey(isPrivate);\n                this.context.allowYield = false;\n                value = this.parseGetterMethod();\n            }\n            else if (token.value === 'set' && lookaheadPropertyKey) {\n                kind = 'set';\n                if (this.match('#')) {\n                    isPrivate = true;\n                    this.nextToken();\n                    token = this.lookahead;\n                }\n                computed = this.match('[');\n                key = this.parseObjectPropertyKey(isPrivate);\n                value = this.parseSetterMethod();\n            }\n            else if (!this.match('(')) {\n                kind = 'property';\n                computed = false;\n                if (this.match('=')) {\n                    this.nextToken();\n                    value = this.isolateCoverGrammar(this.parseAssignmentExpression);\n                }\n            }\n        }\n        else if (token.type === 7 /* Token.Punctuator */ && token.value === '*' && lookaheadPropertyKey) {\n            kind = 'init';\n            computed = this.match('[');\n            key = this.parseObjectPropertyKey(isPrivate);\n            value = this.parseGeneratorMethod(isAsync);\n            method = true;\n        }\n        else if (token.type === 7 /* Token.Punctuator */ && token.value === '[' && !this.match('(')) {\n            kind = 'property';\n            computed = true;\n            if (this.match('=')) {\n                this.nextToken();\n                value = this.isolateCoverGrammar(this.parseAssignmentExpression);\n            }\n        }\n        if (!kind && key && this.match('(')) {\n            var previousInClassConstructor = this.context.inClassConstructor;\n            this.context.inClassConstructor = token.value === 'constructor';\n            kind = 'init';\n            value = isAsync ? this.parsePropertyMethodAsyncFunction(isGenerator) : this.parsePropertyMethodFunction(isGenerator);\n            this.context.inClassConstructor = previousInClassConstructor;\n            method = true;\n        }\n        if (!kind) {\n            this.throwUnexpectedToken(this.lookahead);\n        }\n        if (kind === 'init') {\n            kind = 'method';\n        }\n        if (!computed) {\n            if (isStatic && this.isPropertyKey(key, 'prototype')) {\n                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);\n            }\n            if (!isStatic && this.isPropertyKey(key, 'constructor')) {\n                if (kind !== 'method' || !method || (value && value.generator)) {\n                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);\n                }\n                if (hasConstructor.value) {\n                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);\n                }\n                else {\n                    hasConstructor.value = true;\n                }\n                kind = 'constructor';\n            }\n        }\n        this.context.inConstructor = previousInConstructor;\n        if (kind === 'property') {\n            this.consumeSemicolon();\n            return this.finalize(node, new Node.PropertyDefinition(key, computed, value, isStatic, decorators));\n        }\n        else\n            return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic, decorators));\n    };\n    Parser.prototype.parseClassElementList = function () {\n        var body = [];\n        var hasConstructor = { value: false };\n        this.expect('{');\n        while (!this.match('}')) {\n            if (this.match(';')) {\n                this.nextToken();\n            }\n            else {\n                body.push(this.parseClassElement(hasConstructor));\n            }\n        }\n        this.expect('}');\n        return body;\n    };\n    Parser.prototype.parseClassBody = function () {\n        var node = this.createNode();\n        var elementList = this.parseClassElementList();\n        return this.finalize(node, new Node.ClassBody(elementList));\n    };\n    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {\n        var node = this.createNode();\n        var previousStrict = this.context.strict;\n        var previousAllowSuper = this.context.allowSuper;\n        this.context.strict = true;\n        this.expectKeyword('class');\n        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Token.Identifier */)) ? null : this.parseVariableIdentifier();\n        var superClass = null;\n        if (this.matchKeyword('extends')) {\n            this.nextToken();\n            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n            this.context.allowSuper = true;\n        }\n        var classBody = this.parseClassBody();\n        this.context.allowSuper = previousAllowSuper;\n        this.context.strict = previousStrict;\n        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody, this.context.decorators));\n    };\n    Parser.prototype.parseClassExpression = function () {\n        var node = this.createNode();\n        var previousStrict = this.context.strict;\n        this.context.strict = true;\n        this.expectKeyword('class');\n        var id = (this.lookahead.type === 3 /* Token.Identifier */) ? this.parseVariableIdentifier() : null;\n        var superClass = null;\n        if (this.matchKeyword('extends')) {\n            this.nextToken();\n            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n            this.context.allowSuper = true;\n        }\n        var classBody = this.parseClassBody();\n        this.context.strict = previousStrict;\n        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody, this.context.decorators));\n    };\n    // https://tc39.github.io/ecma262/#sec-scripts\n    // https://tc39.github.io/ecma262/#sec-modules\n    Parser.prototype.parseModule = function () {\n        this.context.strict = true;\n        this.context.isModule = true;\n        this.scanner.isModule = true;\n        var node = this.createNode();\n        var body = this.parseDirectivePrologues();\n        while (this.lookahead.type !== 2 /* Token.EOF */) {\n            body.push(this.parseStatementListItem());\n        }\n        return this.finalize(node, new Node.Module(body));\n    };\n    Parser.prototype.parseScript = function () {\n        var node = this.createNode();\n        var body = this.parseDirectivePrologues();\n        while (this.lookahead.type !== 2 /* Token.EOF */) {\n            body.push(this.parseStatementListItem());\n        }\n        return this.finalize(node, new Node.Script(body));\n    };\n    // https://tc39.github.io/ecma262/#sec-imports\n    Parser.prototype.parseImportAttributes = function () {\n        if (this.lookahead.value === 'assert') {\n            this.nextToken();\n            this.expect('{');\n            var attributes = [];\n            while (!this.match('}')) {\n                attributes.push(this.parseImportAttribute());\n                if (!this.match('}')) {\n                    this.expectCommaSeparator();\n                }\n            }\n            this.expect('}');\n            return attributes;\n        }\n        return null;\n    };\n    Parser.prototype.parseImportAttribute = function () {\n        var node = this.createNode();\n        if (this.lookahead.type !== 3 /* Token.Identifier */) {\n            this.throwUnexpectedToken(this.nextToken());\n        }\n        var key = this.parseIdentifierName();\n        if (!this.match(':')) {\n            this.throwUnexpectedToken(this.nextToken());\n        }\n        this.nextToken();\n        var literalToken = this.nextToken();\n        var raw = this.getTokenRaw(literalToken);\n        var value = this.finalize(node, new Node.Literal(literalToken.value, raw));\n        return this.finalize(node, new Node.ImportAttribute(key, value));\n    };\n    Parser.prototype.parseModuleSpecifier = function () {\n        var node = this.createNode();\n        if (this.lookahead.type !== 8 /* Token.StringLiteral */) {\n            this.throwError(messages_1.Messages.InvalidModuleSpecifier);\n        }\n        var token = this.nextToken();\n        var raw = this.getTokenRaw(token);\n        if (!character_1.Character.isStringWellFormedUnicode(token.value)) {\n            this.throwError(messages_1.Messages.InvalidModuleSpecifier);\n        }\n        return this.finalize(node, new Node.Literal(token.value, raw));\n    };\n    // import {<foo as bar>} ...;\n    Parser.prototype.parseImportSpecifier = function () {\n        var node = this.createNode();\n        var imported;\n        var local;\n        if (this.lookahead.type === 3 /* Token.Identifier */) {\n            imported = this.parseVariableIdentifier();\n            local = imported;\n            if (this.matchContextualKeyword('as')) {\n                this.nextToken();\n                local = this.parseVariableIdentifier();\n            }\n        }\n        else {\n            imported = this.lookahead.type == 8 /* Token.StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n            local = imported;\n            if (this.matchContextualKeyword('as')) {\n                this.nextToken();\n                local = this.parseVariableIdentifier();\n            }\n            else {\n                this.throwUnexpectedToken(this.nextToken());\n            }\n        }\n        return this.finalize(node, new Node.ImportSpecifier(local, imported));\n    };\n    // {foo, bar as bas}\n    Parser.prototype.parseNamedImports = function () {\n        this.expect('{');\n        var specifiers = [];\n        while (!this.match('}')) {\n            specifiers.push(this.parseImportSpecifier());\n            if (!this.match('}')) {\n                this.expect(',');\n            }\n        }\n        this.expect('}');\n        return specifiers;\n    };\n    // import <foo> ...;\n    Parser.prototype.parseImportDefaultSpecifier = function () {\n        var node = this.createNode();\n        var local = this.parseIdentifierName();\n        return this.finalize(node, new Node.ImportDefaultSpecifier(local));\n    };\n    // import <* as foo> ...;\n    Parser.prototype.parseImportNamespaceSpecifier = function () {\n        var node = this.createNode();\n        this.expect('*');\n        if (!this.matchContextualKeyword('as')) {\n            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);\n        }\n        if (this.lookahead.escaped) {\n            this.throwError(messages_1.Messages.NoAsAndFromEscapeSequences);\n        }\n        this.nextToken();\n        var local = this.parseIdentifierName();\n        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));\n    };\n    Parser.prototype.parseImportDeclaration = function () {\n        if (this.context.inFunctionBody) {\n            this.throwError(messages_1.Messages.IllegalImportDeclaration);\n        }\n        var node = this.createNode();\n        this.expectKeyword('import');\n        var src;\n        var specifiers = [];\n        if (this.lookahead.type === 8 /* Token.StringLiteral */) {\n            // import 'foo';\n            src = this.parseModuleSpecifier();\n        }\n        else {\n            if (this.match('{')) {\n                // import {bar}\n                specifiers = specifiers.concat(this.parseNamedImports());\n            }\n            else if (this.match('*')) {\n                // import * as foo\n                specifiers.push(this.parseImportNamespaceSpecifier());\n            }\n            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {\n                // import foo\n                specifiers.push(this.parseImportDefaultSpecifier());\n                if (this.match(',')) {\n                    this.nextToken();\n                    if (this.match('*')) {\n                        // import foo, * as foo\n                        specifiers.push(this.parseImportNamespaceSpecifier());\n                    }\n                    else if (this.match('{')) {\n                        // import foo, {bar}\n                        specifiers = specifiers.concat(this.parseNamedImports());\n                    }\n                    else {\n                        this.throwUnexpectedToken(this.lookahead);\n                    }\n                }\n            }\n            else {\n                this.throwUnexpectedToken(this.nextToken());\n            }\n            if (!this.matchContextualKeyword('from')) {\n                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\n                this.throwError(message, this.lookahead.value);\n            }\n            this.nextToken();\n            src = this.parseModuleSpecifier();\n        }\n        var attributes = this.parseImportAttributes();\n        this.consumeSemicolon();\n        return this.finalize(node, new Node.ImportDeclaration(specifiers, src, attributes));\n    };\n    // https://tc39.github.io/ecma262/#sec-exports\n    Parser.prototype.parseExportSpecifier = function () {\n        var node = this.createNode();\n        var local = this.lookahead.type == 8 /* Token.StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n        var exported = local;\n        if (this.matchContextualKeyword('as')) {\n            if (this.lookahead.escaped) {\n                this.throwError(messages_1.Messages.NoAsAndFromEscapeSequences);\n            }\n            this.nextToken();\n            exported = this.lookahead.type == 8 /* Token.StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n        }\n        return this.finalize(node, new Node.ExportSpecifier(local, exported));\n    };\n    Parser.prototype.parseExportDeclaration = function () {\n        if (this.context.inFunctionBody) {\n            this.throwError(messages_1.Messages.IllegalExportDeclaration);\n        }\n        var node = this.createNode();\n        this.expectKeyword('export');\n        var exportDeclaration;\n        if (this.matchKeyword('default')) {\n            // export default ...\n            this.nextToken();\n            if (this.matchKeyword('function')) {\n                // export default function foo () {}\n                // export default function () {}\n                var declaration = this.parseFunctionDeclaration(true);\n                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n            }\n            else if (this.matchKeyword('class')) {\n                // export default class foo {}\n                var declaration = this.parseClassDeclaration(true);\n                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n            }\n            else if (this.matchContextualKeyword('async')) {\n                // export default async function f () {}\n                // export default async function () {}\n                // export default async x => x\n                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();\n                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n            }\n            else {\n                if (this.matchContextualKeyword('from')) {\n                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);\n                }\n                // export default {};\n                // export default [];\n                // export default (1 + 2);\n                var declaration = this.match('{') ? this.parseObjectInitializer() :\n                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();\n                this.consumeSemicolon();\n                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n            }\n        }\n        else if (this.match('*')) {\n            // export * from 'foo';\n            this.nextToken();\n            var exported = null;\n            if (this.matchContextualKeyword('as')) {\n                if (this.lookahead.escaped) {\n                    this.throwError(messages_1.Messages.NoAsAndFromEscapeSequences);\n                }\n                this.nextToken();\n                exported = this.lookahead.type == 8 /* Token.StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n            }\n            if (!this.matchContextualKeyword('from')) {\n                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\n                this.throwError(message, this.lookahead.value);\n            }\n            if (this.lookahead.escaped) {\n                this.throwError(messages_1.Messages.NoAsAndFromEscapeSequences);\n            }\n            this.nextToken();\n            var src = this.parseModuleSpecifier();\n            var attributes = this.parseImportAttributes();\n            this.consumeSemicolon();\n            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src, exported, attributes));\n        }\n        else if (this.lookahead.type === 4 /* Token.Keyword */) {\n            // export var f = 1;\n            var declaration = void 0;\n            switch (this.lookahead.value) {\n                case 'let':\n                case 'const':\n                    declaration = this.parseLexicalDeclaration({ inFor: false });\n                    break;\n                case 'var':\n                case 'class':\n                case 'function':\n                    declaration = this.parseStatementListItem();\n                    break;\n                default:\n                    this.throwUnexpectedToken(this.lookahead);\n            }\n            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null, null));\n        }\n        else if (this.matchAsyncFunction()) {\n            var declaration = this.parseFunctionDeclaration();\n            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null, null));\n        }\n        else {\n            var specifiers = [];\n            var source = null;\n            var isExportFromIdentifier = false;\n            var attributes = null;\n            this.expect('{');\n            while (!this.match('}')) {\n                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');\n                specifiers.push(this.parseExportSpecifier());\n                if (!this.match('}')) {\n                    this.expect(',');\n                }\n            }\n            this.expect('}');\n            if (this.matchContextualKeyword('from')) {\n                // export {default} from 'foo';\n                // export {foo} from 'foo';\n                if (this.lookahead.escaped) {\n                    this.throwError(messages_1.Messages.NoAsAndFromEscapeSequences);\n                }\n                this.nextToken();\n                source = this.parseModuleSpecifier();\n                attributes = this.parseImportAttributes();\n                this.consumeSemicolon();\n            }\n            else if (isExportFromIdentifier) {\n                // export {default}; // missing fromClause\n                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\n                this.throwError(message, this.lookahead.value);\n            }\n            else {\n                // export {foo};\n                attributes = this.parseImportAttributes();\n                this.consumeSemicolon();\n            }\n            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source, attributes));\n        }\n        return exportDeclaration;\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/parser.js?");

/***/ }),

/***/ "./dist/tsc/cjs/scanner.js":
/*!*********************************!*\
  !*** ./dist/tsc/cjs/scanner.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scanner = void 0;\nvar assert_1 = __webpack_require__(/*! ./assert */ \"./dist/tsc/cjs/assert.js\");\nvar character_1 = __webpack_require__(/*! ./character */ \"./dist/tsc/cjs/character.js\");\nvar messages_1 = __webpack_require__(/*! ./messages */ \"./dist/tsc/cjs/messages.js\");\nfunction hexValue(ch) {\n    return '0123456789abcdef'.indexOf(ch.toLowerCase());\n}\nfunction octalValue(ch) {\n    return '01234567'.indexOf(ch);\n}\nvar Scanner = /** @class */ (function () {\n    function Scanner(code, handler) {\n        this.source = code;\n        this.errorHandler = handler;\n        this.trackComment = false;\n        this.isModule = false;\n        this.length = code.length;\n        this.index = 0;\n        this.lineNumber = (code.length > 0) ? 1 : 0;\n        this.lineStart = 0;\n        this.curlyStack = [];\n    }\n    Scanner.prototype.saveState = function () {\n        return {\n            index: this.index,\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            curlyStack: this.curlyStack.slice()\n        };\n    };\n    Scanner.prototype.restoreState = function (state) {\n        this.index = state.index;\n        this.lineNumber = state.lineNumber;\n        this.lineStart = state.lineStart;\n        this.curlyStack = state.curlyStack;\n    };\n    Scanner.prototype.eof = function () {\n        return this.index >= this.length;\n    };\n    Scanner.prototype.throwUnexpectedToken = function (message) {\n        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }\n        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);\n    };\n    Scanner.prototype.tolerateUnexpectedToken = function (message) {\n        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }\n        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);\n    };\n    // https://tc39.github.io/ecma262/#sec-comments\n    Scanner.prototype.skipSingleLineComment = function (offset) {\n        var comments = [];\n        var start, loc;\n        if (this.trackComment) {\n            comments = [];\n            start = this.index - offset;\n            loc = {\n                start: {\n                    line: this.lineNumber,\n                    column: this.index - this.lineStart - offset\n                },\n                end: {}\n            };\n        }\n        while (!this.eof()) {\n            var ch = this.source.charCodeAt(this.index);\n            ++this.index;\n            if (character_1.Character.isLineTerminator(ch)) {\n                if (this.trackComment) {\n                    loc.end = {\n                        line: this.lineNumber,\n                        column: this.index - this.lineStart - 1\n                    };\n                    var entry = {\n                        multiLine: false,\n                        slice: [start + offset, this.index - 1],\n                        range: [start, this.index - 1],\n                        loc: loc\n                    };\n                    comments.push(entry);\n                }\n                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {\n                    ++this.index;\n                }\n                ++this.lineNumber;\n                this.lineStart = this.index;\n                return comments;\n            }\n        }\n        if (this.trackComment) {\n            loc.end = {\n                line: this.lineNumber,\n                column: this.index - this.lineStart\n            };\n            var entry = {\n                multiLine: false,\n                slice: [start + offset, this.index],\n                range: [start, this.index],\n                loc: loc\n            };\n            comments.push(entry);\n        }\n        return comments;\n    };\n    Scanner.prototype.skipMultiLineComment = function () {\n        var comments = [];\n        var start, loc;\n        if (this.trackComment) {\n            comments = [];\n            start = this.index - 2;\n            loc = {\n                start: {\n                    line: this.lineNumber,\n                    column: this.index - this.lineStart - 2\n                },\n                end: {}\n            };\n        }\n        while (!this.eof()) {\n            var ch = this.source.charCodeAt(this.index);\n            if (character_1.Character.isLineTerminator(ch)) {\n                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {\n                    ++this.index;\n                }\n                ++this.lineNumber;\n                ++this.index;\n                this.lineStart = this.index;\n            }\n            else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (this.source.charCodeAt(this.index + 1) === 0x2F) {\n                    this.index += 2;\n                    if (this.trackComment) {\n                        loc.end = {\n                            line: this.lineNumber,\n                            column: this.index - this.lineStart\n                        };\n                        var entry = {\n                            multiLine: true,\n                            slice: [start + 2, this.index - 2],\n                            range: [start, this.index],\n                            loc: loc\n                        };\n                        comments.push(entry);\n                    }\n                    return comments;\n                }\n                ++this.index;\n            }\n            else {\n                ++this.index;\n            }\n        }\n        // Ran off the end of the file - the whole thing is a comment\n        if (this.trackComment) {\n            loc.end = {\n                line: this.lineNumber,\n                column: this.index - this.lineStart\n            };\n            var entry = {\n                multiLine: true,\n                slice: [start + 2, this.index],\n                range: [start, this.index],\n                loc: loc\n            };\n            comments.push(entry);\n        }\n        this.tolerateUnexpectedToken();\n        return comments;\n    };\n    Scanner.prototype.scanComments = function () {\n        var comments;\n        if (this.trackComment) {\n            comments = [];\n        }\n        var start = (this.index === 0);\n        while (!this.eof()) {\n            var ch = this.source.charCodeAt(this.index);\n            if (character_1.Character.isWhiteSpace(ch)) {\n                ++this.index;\n            }\n            else if (character_1.Character.isLineTerminator(ch)) {\n                ++this.index;\n                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {\n                    ++this.index;\n                }\n                ++this.lineNumber;\n                this.lineStart = this.index;\n                start = true;\n            }\n            else if (ch === 0x2F) { // U+002F is '/'\n                ch = this.source.charCodeAt(this.index + 1);\n                if (ch === 0x2F) {\n                    this.index += 2;\n                    var comment = this.skipSingleLineComment(2);\n                    if (this.trackComment) {\n                        comments = comments.concat(comment);\n                    }\n                    start = true;\n                }\n                else if (ch === 0x2A) { // U+002A is '*'\n                    this.index += 2;\n                    var comment = this.skipMultiLineComment();\n                    if (this.trackComment) {\n                        comments = comments.concat(comment);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    this.index += 3;\n                    var comment = this.skipSingleLineComment(3);\n                    if (this.trackComment) {\n                        comments = comments.concat(comment);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            else if (ch === 0x3C && !this.isModule) { // U+003C is '<'\n                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {\n                    this.index += 4; // `<!--`\n                    var comment = this.skipSingleLineComment(4);\n                    if (this.trackComment) {\n                        comments = comments.concat(comment);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return comments;\n    };\n    // https://tc39.github.io/ecma262/#sec-future-reserved-words\n    Scanner.prototype.isFutureReservedWord = function (id) {\n        switch (id) {\n            case 'enum':\n            case 'export':\n            case 'import':\n            case 'super':\n                return true;\n            default:\n                return false;\n        }\n    };\n    Scanner.prototype.isStrictModeReservedWord = function (id) {\n        switch (id) {\n            case 'implements':\n            case 'interface':\n            case 'package':\n            case 'private':\n            case 'protected':\n            case 'public':\n            case 'static':\n            case 'yield':\n            case 'let':\n                return true;\n            default:\n                return false;\n        }\n    };\n    Scanner.prototype.isRestrictedWord = function (id) {\n        return id === 'eval' || id === 'arguments';\n    };\n    // https://tc39.github.io/ecma262/#sec-keywords\n    Scanner.prototype.isKeyword = function (id) {\n        switch (id.length) {\n            case 2:\n                return (id === 'if') || (id === 'in') || (id === 'do');\n            case 3:\n                return (id === 'var') || (id === 'for') || (id === 'new') ||\n                    (id === 'try') || (id === 'let');\n            case 4:\n                return (id === 'this') || (id === 'else') || (id === 'case') ||\n                    (id === 'void') || (id === 'with') || (id === 'enum');\n            case 5:\n                return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                    (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                    (id === 'class') || (id === 'super');\n            case 6:\n                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                    (id === 'switch') || (id === 'export') || (id === 'import');\n            case 7:\n                return (id === 'default') || (id === 'finally') || (id === 'extends');\n            case 8:\n                return (id === 'function') || (id === 'continue') || (id === 'debugger');\n            case 10:\n                return (id === 'instanceof');\n            default:\n                return false;\n        }\n    };\n    Scanner.prototype.codePointAt = function (i) {\n        var cp = this.source.charCodeAt(i);\n        if (cp >= 0xD800 && cp <= 0xDBFF) {\n            var second = this.source.charCodeAt(i + 1);\n            if (second >= 0xDC00 && second <= 0xDFFF) {\n                var first = cp;\n                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n            }\n        }\n        return cp;\n    };\n    Scanner.prototype.scanHexEscape = function (prefix) {\n        var len = (prefix === 'u') ? 4 : 2;\n        var code = 0;\n        for (var i = 0; i < len; ++i) {\n            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {\n                code = code * 16 + hexValue(this.source[this.index++]);\n            }\n            else {\n                return null;\n            }\n        }\n        return String.fromCharCode(code);\n    };\n    Scanner.prototype.tryToScanUnicodeCodePointEscape = function () {\n        var ch = this.source[this.index];\n        var code = 0;\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            return null;\n        }\n        while (!this.eof()) {\n            ch = this.source[this.index++];\n            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {\n                break;\n            }\n            code = code * 16 + hexValue(ch);\n        }\n        if (code > 0x10FFFF || ch !== '}') {\n            return null;\n        }\n        return character_1.Character.fromCodePoint(code);\n    };\n    Scanner.prototype.scanUnicodeCodePointEscape = function () {\n        var result = this.tryToScanUnicodeCodePointEscape();\n        if (result === null) {\n            return this.throwUnexpectedToken();\n        }\n        return result;\n    };\n    Scanner.prototype.getIdentifier = function () {\n        var start = this.index++;\n        while (!this.eof()) {\n            var ch = this.source.charCodeAt(this.index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                this.index = start;\n                return this.getComplexIdentifier();\n            }\n            else if (ch >= 0xD800 && ch < 0xDFFF) {\n                // Need to handle surrogate pairs.\n                this.index = start;\n                return this.getComplexIdentifier();\n            }\n            if (character_1.Character.isIdentifierPart(ch)) {\n                ++this.index;\n            }\n            else {\n                break;\n            }\n        }\n        return this.source.slice(start, this.index);\n    };\n    Scanner.prototype.getComplexIdentifier = function () {\n        var cp = this.codePointAt(this.index);\n        var id = character_1.Character.fromCodePoint(cp);\n        this.index += id.length;\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        var ch;\n        if (cp === 0x5C) {\n            if (this.source.charCodeAt(this.index) !== 0x75) {\n                this.throwUnexpectedToken();\n            }\n            ++this.index;\n            if (this.source[this.index] === '{') {\n                ++this.index;\n                ch = this.scanUnicodeCodePointEscape();\n            }\n            else {\n                ch = this.scanHexEscape('u');\n                if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {\n                    this.throwUnexpectedToken();\n                }\n            }\n            id = ch;\n        }\n        while (!this.eof()) {\n            cp = this.codePointAt(this.index);\n            if (!character_1.Character.isIdentifierPart(cp)) {\n                break;\n            }\n            ch = character_1.Character.fromCodePoint(cp);\n            id += ch;\n            this.index += ch.length;\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (cp === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (this.source.charCodeAt(this.index) !== 0x75) {\n                    this.throwUnexpectedToken();\n                }\n                ++this.index;\n                if (this.source[this.index] === '{') {\n                    ++this.index;\n                    ch = this.scanUnicodeCodePointEscape();\n                }\n                else {\n                    ch = this.scanHexEscape('u');\n                    if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {\n                        this.throwUnexpectedToken();\n                    }\n                }\n                id += ch;\n            }\n        }\n        return id;\n    };\n    Scanner.prototype.octalToDecimal = function (ch) {\n        // \\0 is not octal escape sequence\n        var octal = (ch !== '0');\n        var code = octalValue(ch);\n        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\n            octal = true;\n            code = code * 8 + octalValue(this.source[this.index++]);\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\n                code = code * 8 + octalValue(this.source[this.index++]);\n            }\n        }\n        return {\n            code: code,\n            octal: octal\n        };\n    };\n    // https://tc39.github.io/ecma262/#sec-names-and-keywords\n    Scanner.prototype.scanIdentifier = function () {\n        var type;\n        var start = this.index;\n        // Backslash (U+005C) starts an escaped character.\n        var escaped = this.source.charCodeAt(start) === 0x5C;\n        var id = escaped ? this.getComplexIdentifier() : this.getIdentifier();\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = 3 /* Token.Identifier */;\n        }\n        else if (this.isKeyword(id)) {\n            type = 4 /* Token.Keyword */;\n        }\n        else if (id === 'null') {\n            type = 5 /* Token.NullLiteral */;\n        }\n        else if (id === 'true' || id === 'false') {\n            type = 1 /* Token.BooleanLiteral */;\n        }\n        else {\n            type = 3 /* Token.Identifier */;\n        }\n        if (type !== 3 /* Token.Identifier */ && (start + id.length !== this.index)) {\n            var restore = this.index;\n            this.index = start;\n            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);\n            this.index = restore;\n        }\n        return {\n            type: type,\n            value: id,\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index,\n            escaped: escaped\n        };\n    };\n    // https://tc39.github.io/ecma262/#sec-punctuators\n    Scanner.prototype.scanPunctuator = function () {\n        var start = this.index;\n        // Check for most common single-character punctuators.\n        var str = this.source[this.index];\n        switch (str) {\n            case '(':\n            case '{':\n                if (str === '{') {\n                    this.curlyStack.push('{');\n                }\n                ++this.index;\n                break;\n            case '.':\n                ++this.index;\n                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {\n                    // Spread operator: ...\n                    this.index += 2;\n                    str = '...';\n                }\n                break;\n            case '}':\n                ++this.index;\n                this.curlyStack.pop();\n                break;\n            case '?':\n                ++this.index;\n                if (this.source[this.index] === '?') {\n                    ++this.index;\n                    if (this.source[this.index] === '=') {\n                        ++this.index;\n                        str = '??=';\n                    }\n                    else {\n                        str = '??';\n                    }\n                }\n                if (this.source[this.index] === '.' && !/^\\d$/.test(this.source[this.index + 1])) {\n                    // \"?.\" in \"foo?.3:0\" should not be treated as optional chaining.\n                    // See https://github.com/tc39/proposal-optional-chaining#notes\n                    ++this.index;\n                    str = '?.';\n                }\n                break;\n            case '#':\n            case ')':\n            case ';':\n            case ',':\n            case '[':\n            case ']':\n            case ':':\n            case '~':\n            case '@':\n                ++this.index;\n                break;\n            default:\n                // 4-character punctuator.\n                str = this.source.substr(this.index, 4);\n                if (str === '>>>=') {\n                    this.index += 4;\n                }\n                else {\n                    // 3-character punctuators.\n                    str = str.substr(0, 3);\n                    if (str === '===' || str === '!==' || str === '>>>' ||\n                        str === '<<=' || str === '>>=' || str === '**=' ||\n                        str === '&&=' || str === '||=') {\n                        this.index += 3;\n                    }\n                    else {\n                        // 2-character punctuators.\n                        str = str.substr(0, 2);\n                        if (str === '&&' || str === '||' ||\n                            str === '==' || str === '!=' ||\n                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||\n                            str === '++' || str === '--' ||\n                            str === '<<' || str === '>>' ||\n                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||\n                            str === '<=' || str === '>=' || str === '=>' ||\n                            str === '**') {\n                            this.index += 2;\n                        }\n                        else {\n                            // 1-character punctuators.\n                            str = this.source[this.index];\n                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                                ++this.index;\n                            }\n                        }\n                    }\n                }\n        }\n        if (this.index === start) {\n            this.throwUnexpectedToken();\n        }\n        return {\n            type: 7 /* Token.Punctuator */,\n            value: str,\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\n    Scanner.prototype.scanHexLiteral = function (start) {\n        var num = this.scanLiteralPart(character_1.Character.isHexDigitChar);\n        if (num.length === 0) {\n            this.throwUnexpectedToken();\n        }\n        if (this.source[this.index] === 'n') {\n            this.index++;\n            return {\n                type: 6 /* Token.NumericLiteral */,\n                value: BigInt('0x' + num),\n                lineNumber: this.lineNumber,\n                lineStart: this.lineStart,\n                start: start,\n                end: this.index\n            };\n        }\n        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\n            this.throwUnexpectedToken();\n        }\n        return {\n            type: 6 /* Token.NumericLiteral */,\n            value: parseInt('0x' + num, 16),\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    Scanner.prototype.scanBinaryLiteral = function (start) {\n        var ch;\n        var num = this.scanLiteralPart(function (c) { return c === '0' || c === '1'; });\n        if (num.length === 0) {\n            // only 0b or 0B\n            this.throwUnexpectedToken();\n        }\n        if (this.source[this.index] === 'n') {\n            this.index++;\n            return {\n                type: 6 /* Token.NumericLiteral */,\n                value: BigInt('0b' + num),\n                lineNumber: this.lineNumber,\n                lineStart: this.lineStart,\n                start: start,\n                end: this.index\n            };\n        }\n        if (!this.eof()) {\n            ch = this.source.charCodeAt(this.index);\n            /* istanbul ignore else */\n            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {\n                this.throwUnexpectedToken();\n            }\n        }\n        return {\n            type: 6 /* Token.NumericLiteral */,\n            value: parseInt(num, 2),\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    Scanner.prototype.scanOctalLiteral = function (prefix, start) {\n        var num = '';\n        var octal = false;\n        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {\n            octal = true;\n            num = '0' + this.source[this.index++];\n        }\n        else {\n            ++this.index;\n        }\n        num += this.scanLiteralPart(character_1.Character.isOctalDigitChar);\n        if (!octal && num.length === 0) {\n            // only 0o or 0O\n            this.throwUnexpectedToken();\n        }\n        if (this.source[this.index] === 'n') {\n            this.index++;\n            return {\n                type: 6 /* Token.NumericLiteral */,\n                value: BigInt('0o' + num),\n                lineNumber: this.lineNumber,\n                lineStart: this.lineStart,\n                start: start,\n                end: this.index\n            };\n        }\n        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n            this.throwUnexpectedToken();\n        }\n        return {\n            type: 6 /* Token.NumericLiteral */,\n            value: parseInt(num, 8),\n            octal: octal,\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    Scanner.prototype.isImplicitOctalLiteral = function () {\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (var i = this.index + 1; i < this.length; ++i) {\n            var ch = this.source[i];\n            if (ch === '8' || ch === '9' || ch === 'n') {\n                return false;\n            }\n            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\n                return true;\n            }\n        }\n        return true;\n    };\n    Scanner.prototype.scanLiteralPart = function (check) {\n        var num = '';\n        if (this.source[this.index] === '_')\n            this.throwUnexpectedToken(messages_1.Messages.NumericSeperatorNotAllowedHere);\n        while (this.source[this.index] && (check(this.source[this.index]) || this.source[this.index] === '_')) {\n            if (this.source[this.index] !== '_')\n                num += this.source[this.index];\n            this.index++;\n            if (this.source[this.index - 1] === '_' && this.source[this.index] === '_')\n                this.throwUnexpectedToken(messages_1.Messages.NumericSeperatorOneUnderscore);\n        }\n        if (this.source[this.index - 1] === '_')\n            this.throwUnexpectedToken(messages_1.Messages.NumericSeperatorNotAllowedHere);\n        return num;\n    };\n    Scanner.prototype.scanNumericLiteral = function () {\n        var start = this.index;\n        var ch = this.source[start];\n        (0, assert_1.assert)(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');\n        var num = '';\n        if (ch !== '.') {\n            num = this.source[this.index++];\n            ch = this.source[this.index];\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (num === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++this.index;\n                    return this.scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++this.index;\n                    return this.scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return this.scanOctalLiteral(ch, start);\n                }\n                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\n                    if (this.isImplicitOctalLiteral()) {\n                        return this.scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n            this.index--;\n            num = this.scanLiteralPart(character_1.Character.isDecimalDigitChar);\n            ch = this.source[this.index];\n        }\n        if (ch === '.') {\n            num += this.source[this.index++];\n            num += this.scanLiteralPart(character_1.Character.isDecimalDigitChar);\n            ch = this.source[this.index];\n        }\n        if (ch === 'e' || ch === 'E') {\n            num += this.source[this.index++];\n            ch = this.source[this.index];\n            if (ch === '+' || ch === '-') {\n                num += this.source[this.index++];\n            }\n            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n                num += this.scanLiteralPart(character_1.Character.isDecimalDigitChar);\n            }\n            else {\n                this.throwUnexpectedToken();\n            }\n        }\n        else if (ch === 'n') {\n            if (num.length > 1 && num[0] === '0') {\n                this.throwUnexpectedToken();\n            }\n            this.index++;\n            return {\n                type: 6 /* Token.NumericLiteral */,\n                value: BigInt(num),\n                lineNumber: this.lineNumber,\n                lineStart: this.lineStart,\n                start: start,\n                end: this.index\n            };\n        }\n        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\n            this.throwUnexpectedToken();\n        }\n        return {\n            type: 6 /* Token.NumericLiteral */,\n            value: parseFloat(num),\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    // https://tc39.github.io/ecma262/#sec-literals-string-literals\n    Scanner.prototype.scanStringLiteral = function () {\n        var start = this.index;\n        var quote = this.source[start];\n        (0, assert_1.assert)((quote === '\\'' || quote === '\"'), 'String literal must starts with a quote');\n        ++this.index;\n        var octal = false;\n        var str = '';\n        while (!this.eof()) {\n            var ch = this.source[this.index++];\n            if (ch === quote) {\n                quote = '';\n                break;\n            }\n            else if (ch === '\\\\') {\n                ch = this.source[this.index++];\n                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                        case 'u':\n                            if (this.source[this.index] === '{') {\n                                ++this.index;\n                                str += this.scanUnicodeCodePointEscape();\n                            }\n                            else {\n                                var unescapedChar = this.scanHexEscape(ch);\n                                if (unescapedChar === null) {\n                                    this.throwUnexpectedToken();\n                                }\n                                str += unescapedChar;\n                            }\n                            break;\n                        case 'x':\n                            var unescaped = this.scanHexEscape(ch);\n                            if (unescaped === null) {\n                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);\n                            }\n                            str += unescaped;\n                            break;\n                        case 'n':\n                            str += '\\n';\n                            break;\n                        case 'r':\n                            str += '\\r';\n                            break;\n                        case 't':\n                            str += '\\t';\n                            break;\n                        case 'b':\n                            str += '\\b';\n                            break;\n                        case 'f':\n                            str += '\\f';\n                            break;\n                        case 'v':\n                            str += '\\x0B';\n                            break;\n                        case '8':\n                        case '9':\n                            str += ch;\n                            this.tolerateUnexpectedToken();\n                            break;\n                        default:\n                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\n                                var octToDec = this.octalToDecimal(ch);\n                                octal = octToDec.octal || octal;\n                                str += String.fromCharCode(octToDec.code);\n                            }\n                            else {\n                                str += ch;\n                            }\n                            break;\n                    }\n                }\n                else {\n                    ++this.lineNumber;\n                    if (ch === '\\r' && this.source[this.index] === '\\n') {\n                        ++this.index;\n                    }\n                    this.lineStart = this.index;\n                }\n            }\n            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            }\n            else {\n                str += ch;\n            }\n        }\n        if (quote !== '') {\n            this.index = start;\n            this.throwUnexpectedToken();\n        }\n        return {\n            type: 8 /* Token.StringLiteral */,\n            value: str,\n            octal: octal,\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components\n    Scanner.prototype.scanTemplate = function () {\n        var cooked = '';\n        var terminated = false;\n        var start = this.index;\n        var head = (this.source[start] === '`');\n        var tail = false;\n        var notEscapeSequenceHead = null;\n        var rawOffset = 2;\n        ++this.index;\n        while (!this.eof()) {\n            var ch = this.source[this.index++];\n            if (ch === '`') {\n                rawOffset = 1;\n                tail = true;\n                terminated = true;\n                break;\n            }\n            else if (ch === '$') {\n                if (this.source[this.index] === '{') {\n                    this.curlyStack.push('${');\n                    ++this.index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            }\n            else if (notEscapeSequenceHead !== null) {\n                continue;\n            }\n            else if (ch === '\\\\') {\n                ch = this.source[this.index++];\n                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                        case 'n':\n                            cooked += '\\n';\n                            break;\n                        case 'r':\n                            cooked += '\\r';\n                            break;\n                        case 't':\n                            cooked += '\\t';\n                            break;\n                        case 'u':\n                            if (this.source[this.index] === '{') {\n                                ++this.index;\n                                var unicodeCodePointEscape = this.tryToScanUnicodeCodePointEscape();\n                                if (unicodeCodePointEscape === null) {\n                                    notEscapeSequenceHead = 'u';\n                                }\n                                else {\n                                    cooked += unicodeCodePointEscape;\n                                }\n                            }\n                            else {\n                                var unescapedChar = this.scanHexEscape(ch);\n                                if (unescapedChar === null) {\n                                    notEscapeSequenceHead = 'u';\n                                }\n                                else {\n                                    cooked += unescapedChar;\n                                }\n                            }\n                            break;\n                        case 'x':\n                            var unescaped = this.scanHexEscape(ch);\n                            if (unescaped === null) {\n                                notEscapeSequenceHead = 'x';\n                            }\n                            else {\n                                cooked += unescaped;\n                            }\n                            break;\n                        case 'b':\n                            cooked += '\\b';\n                            break;\n                        case 'f':\n                            cooked += '\\f';\n                            break;\n                        case 'v':\n                            cooked += '\\v';\n                            break;\n                        default:\n                            if (ch === '0') {\n                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n                                    // NotEscapeSequence: \\01 \\02 and so on\n                                    notEscapeSequenceHead = '0';\n                                }\n                                else {\n                                    cooked += '\\0';\n                                }\n                            }\n                            else if (character_1.Character.isDecimalDigitChar(ch)) {\n                                // NotEscapeSequence: \\1 \\2\n                                notEscapeSequenceHead = ch;\n                            }\n                            else {\n                                cooked += ch;\n                            }\n                            break;\n                    }\n                }\n                else {\n                    ++this.lineNumber;\n                    if (ch === '\\r' && this.source[this.index] === '\\n') {\n                        ++this.index;\n                    }\n                    this.lineStart = this.index;\n                }\n            }\n            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n                ++this.lineNumber;\n                if (ch === '\\r' && this.source[this.index] === '\\n') {\n                    ++this.index;\n                }\n                this.lineStart = this.index;\n                cooked += '\\n';\n            }\n            else {\n                cooked += ch;\n            }\n        }\n        if (!terminated) {\n            this.throwUnexpectedToken();\n        }\n        if (!head) {\n            this.curlyStack.pop();\n        }\n        return {\n            type: 10 /* Token.Template */,\n            value: this.source.slice(start + 1, this.index - rawOffset),\n            cooked: notEscapeSequenceHead === null ? cooked : null,\n            head: head,\n            tail: tail,\n            notEscapeSequenceHead: notEscapeSequenceHead,\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals\n    Scanner.prototype.testRegExp = function (pattern, flags) {\n        var _this = this;\n        // The BMP character to use as a replacement for astral symbols when\n        // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n        // approximation.\n        // Note: replacing with '\\uFFFF' enables false positives in unlikely\n        // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n        // pattern that would not be detected by this substitution.\n        var astralSubstitute = '\\uFFFF';\n        var tmp = pattern;\n        if (flags.indexOf('u') >= 0) {\n            tmp = tmp\n                // Replace every Unicode escape sequence with the equivalent\n                // BMP character or a constant ASCII code point in the case of\n                // astral symbols. (See the above note on `astralSubstitute`\n                // for more information.)\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n                var codePoint = parseInt($1 || $2, 16);\n                if (codePoint > 0x10FFFF) {\n                    _this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);\n                }\n                if (codePoint <= 0xFFFF) {\n                    return String.fromCharCode(codePoint);\n                }\n                return astralSubstitute;\n            })\n                // Replace each paired surrogate with a single ASCII symbol to\n                // avoid throwing on regular expressions that are only valid in\n                // combination with the \"u\" flag.\n                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, astralSubstitute);\n        }\n        // First, detect invalid regular expressions.\n        try {\n            RegExp(tmp);\n        }\n        catch (e) {\n            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);\n        }\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        }\n        catch (exception) {\n            /* istanbul ignore next */\n            return null;\n        }\n    };\n    Scanner.prototype.scanRegExpBody = function () {\n        var ch = this.source[this.index];\n        (0, assert_1.assert)(ch === '/', 'Regular expression literal must start with a slash');\n        var str = this.source[this.index++];\n        var classMarker = false;\n        var terminated = false;\n        while (!this.eof()) {\n            ch = this.source[this.index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = this.source[this.index++];\n                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals\n                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            }\n            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\n            }\n            else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            }\n            else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                }\n                else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n        if (!terminated) {\n            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\n        }\n        // Exclude leading and trailing slash.\n        return str.substr(1, str.length - 2);\n    };\n    Scanner.prototype.scanRegExpFlags = function () {\n        var str = '';\n        var flags = '';\n        while (!this.eof()) {\n            var ch = this.source[this.index];\n            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n            ++this.index;\n            if (ch === '\\\\' && !this.eof()) {\n                ch = this.source[this.index];\n                if (ch === 'u') {\n                    ++this.index;\n                    var restore = this.index;\n                    var char = this.scanHexEscape('u');\n                    if (char !== null) {\n                        flags += char;\n                        for (str += '\\\\u'; restore < this.index; ++restore) {\n                            str += this.source[restore];\n                        }\n                    }\n                    else {\n                        this.index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    this.tolerateUnexpectedToken();\n                }\n                else {\n                    str += '\\\\';\n                    this.tolerateUnexpectedToken();\n                }\n            }\n            else {\n                flags += ch;\n                str += ch;\n            }\n        }\n        return flags;\n    };\n    Scanner.prototype.scanRegExp = function () {\n        var start = this.index;\n        var pattern = this.scanRegExpBody();\n        var flags = this.scanRegExpFlags();\n        var value = this.testRegExp(pattern, flags);\n        return {\n            type: 9 /* Token.RegularExpression */,\n            value: '',\n            pattern: pattern,\n            flags: flags,\n            regex: value,\n            lineNumber: this.lineNumber,\n            lineStart: this.lineStart,\n            start: start,\n            end: this.index\n        };\n    };\n    Scanner.prototype.lex = function () {\n        if (this.eof()) {\n            return {\n                type: 2 /* Token.EOF */,\n                value: '',\n                lineNumber: this.lineNumber,\n                lineStart: this.lineStart,\n                start: this.index,\n                end: this.index\n            };\n        }\n        var cp = this.source.charCodeAt(this.index);\n        if (character_1.Character.isIdentifierStart(cp)) {\n            return this.scanIdentifier();\n        }\n        // Very common: ( and ) and ;\n        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\n            return this.scanPunctuator();\n        }\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (cp === 0x27 || cp === 0x22) {\n            return this.scanStringLiteral();\n        }\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (cp === 0x2E) {\n            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {\n                return this.scanNumericLiteral();\n            }\n            return this.scanPunctuator();\n        }\n        if (character_1.Character.isDecimalDigit(cp)) {\n            return this.scanNumericLiteral();\n        }\n        // Template literals start with ` (U+0060) for template head\n        // or } (U+007D) for template middle or template tail.\n        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {\n            return this.scanTemplate();\n        }\n        // Possible identifier start in a surrogate pair.\n        if (cp >= 0xD800 && cp < 0xDFFF) {\n            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {\n                return this.scanIdentifier();\n            }\n        }\n        return this.scanPunctuator();\n    };\n    return Scanner;\n}());\nexports.Scanner = Scanner;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/scanner.js?");

/***/ }),

/***/ "./dist/tsc/cjs/syntax.js":
/*!********************************!*\
  !*** ./dist/tsc/cjs/syntax.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Syntax = void 0;\nvar Syntax;\n(function (Syntax) {\n    Syntax[\"AssignmentExpression\"] = \"AssignmentExpression\";\n    Syntax[\"AssignmentPattern\"] = \"AssignmentPattern\";\n    Syntax[\"ArrayExpression\"] = \"ArrayExpression\";\n    Syntax[\"ArrayPattern\"] = \"ArrayPattern\";\n    Syntax[\"ArrowFunctionExpression\"] = \"ArrowFunctionExpression\";\n    Syntax[\"AwaitExpression\"] = \"AwaitExpression\";\n    Syntax[\"BlockStatement\"] = \"BlockStatement\";\n    Syntax[\"BinaryExpression\"] = \"BinaryExpression\";\n    Syntax[\"BreakStatement\"] = \"BreakStatement\";\n    Syntax[\"CallExpression\"] = \"CallExpression\";\n    Syntax[\"CatchClause\"] = \"CatchClause\";\n    Syntax[\"ChainExpression\"] = \"ChainExpression\";\n    Syntax[\"ClassBody\"] = \"ClassBody\";\n    Syntax[\"ClassDeclaration\"] = \"ClassDeclaration\";\n    Syntax[\"ClassExpression\"] = \"ClassExpression\";\n    Syntax[\"ConditionalExpression\"] = \"ConditionalExpression\";\n    Syntax[\"ContinueStatement\"] = \"ContinueStatement\";\n    Syntax[\"Decorator\"] = \"Decorator\";\n    Syntax[\"DoWhileStatement\"] = \"DoWhileStatement\";\n    Syntax[\"DebuggerStatement\"] = \"DebuggerStatement\";\n    Syntax[\"EmptyStatement\"] = \"EmptyStatement\";\n    Syntax[\"ExportAllDeclaration\"] = \"ExportAllDeclaration\";\n    Syntax[\"ExportDefaultDeclaration\"] = \"ExportDefaultDeclaration\";\n    Syntax[\"ExportNamedDeclaration\"] = \"ExportNamedDeclaration\";\n    Syntax[\"ExportSpecifier\"] = \"ExportSpecifier\";\n    Syntax[\"ExpressionStatement\"] = \"ExpressionStatement\";\n    Syntax[\"ForStatement\"] = \"ForStatement\";\n    Syntax[\"ForOfStatement\"] = \"ForOfStatement\";\n    Syntax[\"ForInStatement\"] = \"ForInStatement\";\n    Syntax[\"FunctionDeclaration\"] = \"FunctionDeclaration\";\n    Syntax[\"FunctionExpression\"] = \"FunctionExpression\";\n    Syntax[\"Identifier\"] = \"Identifier\";\n    Syntax[\"IfStatement\"] = \"IfStatement\";\n    Syntax[\"ImportAttribute\"] = \"ImportAttribute\";\n    Syntax[\"ImportExpression\"] = \"ImportExpression\";\n    Syntax[\"ImportDeclaration\"] = \"ImportDeclaration\";\n    Syntax[\"ImportDefaultSpecifier\"] = \"ImportDefaultSpecifier\";\n    Syntax[\"ImportNamespaceSpecifier\"] = \"ImportNamespaceSpecifier\";\n    Syntax[\"ImportSpecifier\"] = \"ImportSpecifier\";\n    Syntax[\"Literal\"] = \"Literal\";\n    Syntax[\"LabeledStatement\"] = \"LabeledStatement\";\n    Syntax[\"LogicalExpression\"] = \"LogicalExpression\";\n    Syntax[\"MemberExpression\"] = \"MemberExpression\";\n    Syntax[\"MetaProperty\"] = \"MetaProperty\";\n    Syntax[\"MethodDefinition\"] = \"MethodDefinition\";\n    Syntax[\"NewExpression\"] = \"NewExpression\";\n    Syntax[\"ObjectExpression\"] = \"ObjectExpression\";\n    Syntax[\"ObjectPattern\"] = \"ObjectPattern\";\n    Syntax[\"Program\"] = \"Program\";\n    Syntax[\"Property\"] = \"Property\";\n    Syntax[\"PrivateIdentifier\"] = \"PrivateIdentifier\";\n    Syntax[\"RestElement\"] = \"RestElement\";\n    Syntax[\"ReturnStatement\"] = \"ReturnStatement\";\n    Syntax[\"SequenceExpression\"] = \"SequenceExpression\";\n    Syntax[\"SpreadElement\"] = \"SpreadElement\";\n    Syntax[\"StaticBlock\"] = \"StaticBlock\";\n    Syntax[\"Super\"] = \"Super\";\n    Syntax[\"SwitchCase\"] = \"SwitchCase\";\n    Syntax[\"SwitchStatement\"] = \"SwitchStatement\";\n    Syntax[\"TaggedTemplateExpression\"] = \"TaggedTemplateExpression\";\n    Syntax[\"TemplateElement\"] = \"TemplateElement\";\n    Syntax[\"TemplateLiteral\"] = \"TemplateLiteral\";\n    Syntax[\"ThisExpression\"] = \"ThisExpression\";\n    Syntax[\"ThrowStatement\"] = \"ThrowStatement\";\n    Syntax[\"TryStatement\"] = \"TryStatement\";\n    Syntax[\"UnaryExpression\"] = \"UnaryExpression\";\n    Syntax[\"UpdateExpression\"] = \"UpdateExpression\";\n    Syntax[\"VariableDeclaration\"] = \"VariableDeclaration\";\n    Syntax[\"VariableDeclarator\"] = \"VariableDeclarator\";\n    Syntax[\"WhileStatement\"] = \"WhileStatement\";\n    Syntax[\"WithStatement\"] = \"WithStatement\";\n    Syntax[\"YieldExpression\"] = \"YieldExpression\";\n})(Syntax = exports.Syntax || (exports.Syntax = {}));\n;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/syntax.js?");

/***/ }),

/***/ "./dist/tsc/cjs/token.js":
/*!*******************************!*\
  !*** ./dist/tsc/cjs/token.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenName = void 0;\nexports.TokenName = {};\nexports.TokenName[1] = 'Boolean';\nexports.TokenName[2] = '<end>';\nexports.TokenName[3] = 'Identifier';\nexports.TokenName[4] = 'Keyword';\nexports.TokenName[5] = 'Null';\nexports.TokenName[6] = 'Numeric';\nexports.TokenName[7] = 'Punctuator';\nexports.TokenName[8] = 'String';\nexports.TokenName[9] = 'RegularExpression';\nexports.TokenName[10] = 'Template';\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/token.js?");

/***/ }),

/***/ "./dist/tsc/cjs/tokenizer.js":
/*!***********************************!*\
  !*** ./dist/tsc/cjs/tokenizer.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tokenizer = void 0;\nvar error_handler_1 = __webpack_require__(/*! ./error-handler */ \"./dist/tsc/cjs/error-handler.js\");\nvar scanner_1 = __webpack_require__(/*! ./scanner */ \"./dist/tsc/cjs/scanner.js\");\nvar token_1 = __webpack_require__(/*! ./token */ \"./dist/tsc/cjs/token.js\");\nvar beforeFunctionExpressionTokens = [\n    '(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n    'return', 'case', 'delete', 'throw', 'void',\n    // assignment operators\n    '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',\n    '&=', '|=', '^=', ',',\n    // binary/unary operators\n    '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n    '|', '^', '!', '~', '&&', '||', '??', '?', ':', '===', '==', '>=',\n    '<=', '<', '>', '!=', '!=='\n];\nvar Reader = /** @class */ (function () {\n    function Reader() {\n        this.values = [];\n        this.curly = this.paren = -1;\n    }\n    // A function following one of those tokens is an expression.\n    Reader.prototype.beforeFunctionExpression = function (t) {\n        return beforeFunctionExpressionTokens.includes(t);\n    };\n    // Determine if forward slash (/) is an operator or part of a regular expression\n    // https://github.com/mozilla/sweet.js/wiki/design\n    Reader.prototype.isRegexStart = function () {\n        var previous = this.values[this.values.length - 1];\n        var regex = (previous !== null);\n        switch (previous) {\n            case 'this':\n            case ']':\n                regex = false;\n                break;\n            case ')':\n                var keyword = this.values[this.paren - 1];\n                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');\n                break;\n            case '}':\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                regex = true;\n                if (this.values[this.curly - 3] === 'function') {\n                    // Anonymous function, e.g. function(){} /42\n                    var check = this.values[this.curly - 4];\n                    regex = check ? !this.beforeFunctionExpression(check) : false;\n                }\n                else if (this.values[this.curly - 4] === 'function') {\n                    // Named function, e.g. function f(){} /42/\n                    var check = this.values[this.curly - 5];\n                    regex = check ? !this.beforeFunctionExpression(check) : true;\n                }\n                break;\n            default:\n                break;\n        }\n        return regex;\n    };\n    Reader.prototype.push = function (token) {\n        if (token.type === 7 /* Token.Punctuator */ || token.type === 4 /* Token.Keyword */) {\n            if (token.value === '{') {\n                this.curly = this.values.length;\n            }\n            else if (token.value === '(') {\n                this.paren = this.values.length;\n            }\n            this.values.push(token.value);\n        }\n        else {\n            this.values.push(null);\n        }\n    };\n    return Reader;\n}());\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(code, config) {\n        this.errorHandler = new error_handler_1.ErrorHandler();\n        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;\n        this.scanner = new scanner_1.Scanner(code, this.errorHandler);\n        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;\n        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;\n        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;\n        this.buffer = [];\n        this.reader = new Reader();\n    }\n    Tokenizer.prototype.errors = function () {\n        return this.errorHandler.errors;\n    };\n    Tokenizer.prototype.getNextToken = function () {\n        if (this.buffer.length === 0) {\n            var comments = this.scanner.scanComments();\n            if (this.scanner.trackComment) {\n                for (var i = 0; i < comments.length; ++i) {\n                    var e = comments[i];\n                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);\n                    var comment = {\n                        type: e.multiLine ? 'BlockComment' : 'LineComment',\n                        value: value\n                    };\n                    if (this.trackRange) {\n                        comment.range = e.range;\n                    }\n                    if (this.trackLoc) {\n                        comment.loc = e.loc;\n                    }\n                    this.buffer.push(comment);\n                }\n            }\n            if (!this.scanner.eof()) {\n                var loc = void 0;\n                if (this.trackLoc) {\n                    loc = {\n                        start: {\n                            line: this.scanner.lineNumber,\n                            column: this.scanner.index - this.scanner.lineStart\n                        },\n                        end: {}\n                    };\n                }\n                var maybeRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();\n                var token = void 0;\n                if (maybeRegex) {\n                    var state = this.scanner.saveState();\n                    try {\n                        token = this.scanner.scanRegExp();\n                    }\n                    catch (e) {\n                        this.scanner.restoreState(state);\n                        token = this.scanner.lex();\n                    }\n                }\n                else {\n                    token = this.scanner.lex();\n                }\n                this.reader.push(token);\n                var entry = {\n                    type: token_1.TokenName[token.type],\n                    value: this.scanner.source.slice(token.start, token.end)\n                };\n                if (this.trackRange) {\n                    entry.range = [token.start, token.end];\n                }\n                if (this.trackLoc) {\n                    loc.end = {\n                        line: this.scanner.lineNumber,\n                        column: this.scanner.index - this.scanner.lineStart\n                    };\n                    entry.loc = loc;\n                }\n                if (token.type === 9 /* Token.RegularExpression */) {\n                    var pattern = token.pattern;\n                    var flags = token.flags;\n                    entry.regex = { pattern: pattern, flags: flags };\n                }\n                this.buffer.push(entry);\n            }\n        }\n        return this.buffer.shift();\n    };\n    return Tokenizer;\n}());\nexports.Tokenizer = Tokenizer;\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/tokenizer.js?");

/***/ }),

/***/ "./dist/tsc/cjs/xhtml-entities.js":
/*!****************************************!*\
  !*** ./dist/tsc/cjs/xhtml-entities.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Generated by generate-xhtml-entities.js. DO NOT MODIFY!\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.XHTMLEntities = void 0;\nexports.XHTMLEntities = {\n    quot: '\\u0022',\n    amp: '\\u0026',\n    apos: '\\u0027',\n    gt: '\\u003E',\n    nbsp: '\\u00A0',\n    iexcl: '\\u00A1',\n    cent: '\\u00A2',\n    pound: '\\u00A3',\n    curren: '\\u00A4',\n    yen: '\\u00A5',\n    brvbar: '\\u00A6',\n    sect: '\\u00A7',\n    uml: '\\u00A8',\n    copy: '\\u00A9',\n    ordf: '\\u00AA',\n    laquo: '\\u00AB',\n    not: '\\u00AC',\n    shy: '\\u00AD',\n    reg: '\\u00AE',\n    macr: '\\u00AF',\n    deg: '\\u00B0',\n    plusmn: '\\u00B1',\n    sup2: '\\u00B2',\n    sup3: '\\u00B3',\n    acute: '\\u00B4',\n    micro: '\\u00B5',\n    para: '\\u00B6',\n    middot: '\\u00B7',\n    cedil: '\\u00B8',\n    sup1: '\\u00B9',\n    ordm: '\\u00BA',\n    raquo: '\\u00BB',\n    frac14: '\\u00BC',\n    frac12: '\\u00BD',\n    frac34: '\\u00BE',\n    iquest: '\\u00BF',\n    Agrave: '\\u00C0',\n    Aacute: '\\u00C1',\n    Acirc: '\\u00C2',\n    Atilde: '\\u00C3',\n    Auml: '\\u00C4',\n    Aring: '\\u00C5',\n    AElig: '\\u00C6',\n    Ccedil: '\\u00C7',\n    Egrave: '\\u00C8',\n    Eacute: '\\u00C9',\n    Ecirc: '\\u00CA',\n    Euml: '\\u00CB',\n    Igrave: '\\u00CC',\n    Iacute: '\\u00CD',\n    Icirc: '\\u00CE',\n    Iuml: '\\u00CF',\n    ETH: '\\u00D0',\n    Ntilde: '\\u00D1',\n    Ograve: '\\u00D2',\n    Oacute: '\\u00D3',\n    Ocirc: '\\u00D4',\n    Otilde: '\\u00D5',\n    Ouml: '\\u00D6',\n    times: '\\u00D7',\n    Oslash: '\\u00D8',\n    Ugrave: '\\u00D9',\n    Uacute: '\\u00DA',\n    Ucirc: '\\u00DB',\n    Uuml: '\\u00DC',\n    Yacute: '\\u00DD',\n    THORN: '\\u00DE',\n    szlig: '\\u00DF',\n    agrave: '\\u00E0',\n    aacute: '\\u00E1',\n    acirc: '\\u00E2',\n    atilde: '\\u00E3',\n    auml: '\\u00E4',\n    aring: '\\u00E5',\n    aelig: '\\u00E6',\n    ccedil: '\\u00E7',\n    egrave: '\\u00E8',\n    eacute: '\\u00E9',\n    ecirc: '\\u00EA',\n    euml: '\\u00EB',\n    igrave: '\\u00EC',\n    iacute: '\\u00ED',\n    icirc: '\\u00EE',\n    iuml: '\\u00EF',\n    eth: '\\u00F0',\n    ntilde: '\\u00F1',\n    ograve: '\\u00F2',\n    oacute: '\\u00F3',\n    ocirc: '\\u00F4',\n    otilde: '\\u00F5',\n    ouml: '\\u00F6',\n    divide: '\\u00F7',\n    oslash: '\\u00F8',\n    ugrave: '\\u00F9',\n    uacute: '\\u00FA',\n    ucirc: '\\u00FB',\n    uuml: '\\u00FC',\n    yacute: '\\u00FD',\n    thorn: '\\u00FE',\n    yuml: '\\u00FF',\n    OElig: '\\u0152',\n    oelig: '\\u0153',\n    Scaron: '\\u0160',\n    scaron: '\\u0161',\n    Yuml: '\\u0178',\n    fnof: '\\u0192',\n    circ: '\\u02C6',\n    tilde: '\\u02DC',\n    Alpha: '\\u0391',\n    Beta: '\\u0392',\n    Gamma: '\\u0393',\n    Delta: '\\u0394',\n    Epsilon: '\\u0395',\n    Zeta: '\\u0396',\n    Eta: '\\u0397',\n    Theta: '\\u0398',\n    Iota: '\\u0399',\n    Kappa: '\\u039A',\n    Lambda: '\\u039B',\n    Mu: '\\u039C',\n    Nu: '\\u039D',\n    Xi: '\\u039E',\n    Omicron: '\\u039F',\n    Pi: '\\u03A0',\n    Rho: '\\u03A1',\n    Sigma: '\\u03A3',\n    Tau: '\\u03A4',\n    Upsilon: '\\u03A5',\n    Phi: '\\u03A6',\n    Chi: '\\u03A7',\n    Psi: '\\u03A8',\n    Omega: '\\u03A9',\n    alpha: '\\u03B1',\n    beta: '\\u03B2',\n    gamma: '\\u03B3',\n    delta: '\\u03B4',\n    epsilon: '\\u03B5',\n    zeta: '\\u03B6',\n    eta: '\\u03B7',\n    theta: '\\u03B8',\n    iota: '\\u03B9',\n    kappa: '\\u03BA',\n    lambda: '\\u03BB',\n    mu: '\\u03BC',\n    nu: '\\u03BD',\n    xi: '\\u03BE',\n    omicron: '\\u03BF',\n    pi: '\\u03C0',\n    rho: '\\u03C1',\n    sigmaf: '\\u03C2',\n    sigma: '\\u03C3',\n    tau: '\\u03C4',\n    upsilon: '\\u03C5',\n    phi: '\\u03C6',\n    chi: '\\u03C7',\n    psi: '\\u03C8',\n    omega: '\\u03C9',\n    thetasym: '\\u03D1',\n    upsih: '\\u03D2',\n    piv: '\\u03D6',\n    ensp: '\\u2002',\n    emsp: '\\u2003',\n    thinsp: '\\u2009',\n    zwnj: '\\u200C',\n    zwj: '\\u200D',\n    lrm: '\\u200E',\n    rlm: '\\u200F',\n    ndash: '\\u2013',\n    mdash: '\\u2014',\n    lsquo: '\\u2018',\n    rsquo: '\\u2019',\n    sbquo: '\\u201A',\n    ldquo: '\\u201C',\n    rdquo: '\\u201D',\n    bdquo: '\\u201E',\n    dagger: '\\u2020',\n    Dagger: '\\u2021',\n    bull: '\\u2022',\n    hellip: '\\u2026',\n    permil: '\\u2030',\n    prime: '\\u2032',\n    Prime: '\\u2033',\n    lsaquo: '\\u2039',\n    rsaquo: '\\u203A',\n    oline: '\\u203E',\n    frasl: '\\u2044',\n    euro: '\\u20AC',\n    image: '\\u2111',\n    weierp: '\\u2118',\n    real: '\\u211C',\n    trade: '\\u2122',\n    alefsym: '\\u2135',\n    larr: '\\u2190',\n    uarr: '\\u2191',\n    rarr: '\\u2192',\n    darr: '\\u2193',\n    harr: '\\u2194',\n    crarr: '\\u21B5',\n    lArr: '\\u21D0',\n    uArr: '\\u21D1',\n    rArr: '\\u21D2',\n    dArr: '\\u21D3',\n    hArr: '\\u21D4',\n    forall: '\\u2200',\n    part: '\\u2202',\n    exist: '\\u2203',\n    empty: '\\u2205',\n    nabla: '\\u2207',\n    isin: '\\u2208',\n    notin: '\\u2209',\n    ni: '\\u220B',\n    prod: '\\u220F',\n    sum: '\\u2211',\n    minus: '\\u2212',\n    lowast: '\\u2217',\n    radic: '\\u221A',\n    prop: '\\u221D',\n    infin: '\\u221E',\n    ang: '\\u2220',\n    and: '\\u2227',\n    or: '\\u2228',\n    cap: '\\u2229',\n    cup: '\\u222A',\n    int: '\\u222B',\n    there4: '\\u2234',\n    sim: '\\u223C',\n    cong: '\\u2245',\n    asymp: '\\u2248',\n    ne: '\\u2260',\n    equiv: '\\u2261',\n    le: '\\u2264',\n    ge: '\\u2265',\n    sub: '\\u2282',\n    sup: '\\u2283',\n    nsub: '\\u2284',\n    sube: '\\u2286',\n    supe: '\\u2287',\n    oplus: '\\u2295',\n    otimes: '\\u2297',\n    perp: '\\u22A5',\n    sdot: '\\u22C5',\n    lceil: '\\u2308',\n    rceil: '\\u2309',\n    lfloor: '\\u230A',\n    rfloor: '\\u230B',\n    loz: '\\u25CA',\n    spades: '\\u2660',\n    clubs: '\\u2663',\n    hearts: '\\u2665',\n    diams: '\\u2666',\n    lang: '\\u27E8',\n    rang: '\\u27E9'\n};\n\n\n//# sourceURL=webpack://esprima/./dist/tsc/cjs/xhtml-entities.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./dist/tsc/cjs/esprima.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
